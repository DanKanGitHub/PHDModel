// Departure Feet algorithm
// Uses only the velocity element and passes back both the departure velocity
// and the departure stress

//Gauss_Pt_Num = Nem * N_TRI_QUAD; // No Gauss points are shared   
//Depart_Vel.Shape(Gauss_Pt_Num,2);
//Depart_Str.Shape(Gauss_Pt_Num,3);

#include "FeetSearch.h"
#include "Shape2d.h"
#include "DepartureInfo.h"
#include "Epetra_SerialDenseMatrix.h"
#include "Epetra_IntSerialDenseMatrix.h"
#include "Epetra_SerialDenseVector.h"

typedef Epetra_SerialDenseMatrix E_SDM;
typedef Epetra_IntSerialDenseMatrix E_ISDM;
typedef Epetra_SerialDenseVector E_SDV;

void DepartureInfo(int Vel_Flag, 
		   int Pre_Flag, 
		   int N_TRI_QUAD, 
		   int Nem, 
		   E_SDM Tri_Quad_Pt, 
		   double TIMESTEP,
		   E_SDM Vel, 
		   E_SDM Str, 
		   E_SDM Vel_Glxy, 
		   E_SDM Pre_Glxy, 
		   int Vel_Npe, 
		   int Pre_Npe, 
		   E_ISDM Vel_Nod, 
		   E_ISDM Pre_Nod, 
		   E_ISDM Ele_Neigh, 
		   E_SDM & Depart_Vel, 
		   E_SDM & Depart_Str)
{
  
  // Velocity terms
  E_SDM El_Vel, Grad_Vel, Det_Inv_Grad_Vel, Vel_Elxy, Ini_Depart_Vel;
  E_SDV It_Vel; // iterative velocity
  double Det_Grad_Vel, Trace_Grad_Vel;
  
  // Stress terms
  E_SDM El_Str, Str_Elxy, Str_Gdsf, Ini_Depart_Str;
  E_SDV It_Str, Str_Sf; // iterative stress
  
  // Other
  E_SDM Gdsf, A, Depart_Feet, Ini_Depart_Feet;
  E_SDV Y_Norm, X, Y_New, Y_Old, Y_New_Xi_Eta, Sf, B;
  int Inod, Gauss_Pt, Cur_Ele, New_Ele;
  double Xi, Eta, DetJ, Coeff, Feet_Tol, TOL = 0.00001; // Same tolerance as in main
  double A1, A2, B1, B2, C1, C2, Area, x_Foot, y_Foot;
  
  // Initialize
  // Velocity terms
  El_Vel.Shape(2,Vel_Npe);
  It_Vel.Size(2);
  Det_Inv_Grad_Vel.Shape(2,2);
  Grad_Vel.Shape(2,2);
  Vel_Elxy.Shape(Vel_Npe,2);
  Ini_Depart_Vel.Shape(Nem * N_TRI_QUAD, 2);
  
  // Stress terms
  El_Str.Shape(4,Pre_Npe); // Can't reduce the size needed for matrix multi
  It_Str.Size(3);
  Str_Elxy.Shape(Pre_Npe,2);
  Str_Sf.Size(Pre_Npe);
  Str_Gdsf.Shape(2,Pre_Npe);
  Ini_Depart_Str.Shape(Nem * N_TRI_QUAD, 3);
  
  // Other terms
  X.Size(2);
  Y_New.Size(2);
  Y_Old.Size(2);
  Y_New_Xi_Eta.Size(2);
  Y_Norm.Size(2);
  Sf.Size(Vel_Npe);  		// value of shape functions at (xi,eta)
  Gdsf.Shape(2,Vel_Npe); 	// derivatives w.r.t. global cooridinates
  A.Shape(2,2);
  B.Size(2);
  Depart_Feet.Shape(Nem * N_TRI_QUAD,2);
  Ini_Depart_Feet.Shape(Nem * N_TRI_QUAD, 2);
  
  // All correct
//   std::cout << "Vel_Glxy = " << Vel_Glxy << endl;
//   std::cout << "Vel_Nod = " << Vel_Nod << endl;
//   std::cout << "Vel = " << Vel << endl;
//   std::cout << "Vel_Glxy = " << Vel_Glxy << endl;
  
//   Area = 1.0 / 8.0; // 1/2 * b * h with b = h = 1/2 for this basic mesh case
  // In general Area = 1.0 / 2.0 * (x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3 + x1 * y2 - x2 * y1);
  
  for (int Ne = 0; Ne <= Nem-1; Ne++) 		// loop over all the elements
  {    
//     std::cout << "Element = " << Ne + 1 << endl;
    
    // Gauss Points are all we care about
    for (int Ni = 0; Ni <= N_TRI_QUAD-1; Ni++)  // loop over quadrature points
    {
      
      Gauss_Pt = Ni + N_TRI_QUAD * Ne; // All gauss points are inter-element, hence no shared gauss points.
      
      // Barycentric cooridinates of the gauss point
      Xi  = Tri_Quad_Pt(Ni,0);
      Eta = Tri_Quad_Pt(Ni,1);
      
      // Compute the initial stress at the departure foot
      for (int i = 0; i <= Pre_Npe - 1; i++) 	// get global coordinates of local nodes of element NE
      {
	Inod = Pre_Nod(Ne, i) - 1;	// Global node number (minus one for C++ indexing) of local node.
	Str_Elxy(i,0) = Pre_Glxy(Inod,0);	// x-coordinate
	Str_Elxy(i,1) = Pre_Glxy(Inod,1);	// y-coordinate
      
	El_Str(0,i) = Str(Inod,0);
	El_Str(1,i) = Str(Inod,1);
	El_Str(2,i) = El_Str(1,i); // The stress tensor is symmetric
	El_Str(3,i) = Str(Inod,2);
      }

      Shape2d(Xi, 
	      Eta, 
	      Str_Elxy, 
	      Pre_Npe, 	// Both stress and pressure are linear
	      Pre_Flag, 
	      Str_Sf, 	// output
	      Str_Gdsf, // output
	      DetJ);	// output

//       std::cout << "It_Str = " << It_Str << endl;
      
      for(int i = 0; i <= 2; i++)
      {
	It_Str(i) = 0.0;
      }
      
//       It_Str(0) = 0.0;
//       It_Str(1) = 0.0;
//       It_Str(2) = 0.0;
//       
//       std::cout << "It_Str = " << It_Str << endl;
      
      for(int j = 0; j <= Pre_Npe - 1; j++)
      {
	It_Str(0) += El_Str(0,j) * Str_Sf(j);
	It_Str(1) += El_Str(1,j) * Str_Sf(j);
	It_Str(2) += El_Str(3,j) * Str_Sf(j); // Since the Str is symmetric
      }

      Ini_Depart_Str(Gauss_Pt,0) = It_Str(0);
      Ini_Depart_Str(Gauss_Pt,1) = It_Str(1);
      Ini_Depart_Str(Gauss_Pt,2) = It_Str(2);
      
      // Initialize the while loop
      // Element velocity info
      for (int i = 0; i <= Vel_Npe-1; i++) 	// get global coordinates of local nodes of element NE
      {
	Inod = Vel_Nod(Ne, i)-1;			// Global node number (minus one for indexing) of local node.
	Vel_Elxy(i,0) = Vel_Glxy(Inod, 0);	// x-coordinate
	Vel_Elxy(i,1) = Vel_Glxy(Inod, 1);	// y-coordinate
      
	El_Vel(0,i) = Vel(Inod,0);
	El_Vel(1,i) = Vel(Inod,1);
      }
    
//       std::cout << "Vel_Elxy = " << Vel_Elxy << endl; 

    // All correct
//     std::cout << "Vel_Npe = " << Vel_Npe << endl;
//     std::cout << "Vel_Elxy = " << Vel_Elxy << endl;
//     std::cout << "El_Vel = " << El_Vel << endl;

      // X is the starting position vector and is constant throughout the loop
      X(0) = Xi;
      X(1) = Eta;
      
      double alpha1, alpha2, alpha3;
      
      alpha1 = Vel_Elxy(1,0) * Vel_Elxy(2,1) - Vel_Elxy(2,0) * Vel_Elxy(1,1); // x2 * y3 - x3 * y2
      alpha2 = Vel_Elxy(2,0) * Vel_Elxy(0,1) - Vel_Elxy(0,0) * Vel_Elxy(2,1); // x3 * y1 - x1 * y3
      alpha3 = Vel_Elxy(0,0) * Vel_Elxy(1,1) - Vel_Elxy(1,0) * Vel_Elxy(0,1); // x1 * y2 - x2 * y1
      
      // In general: 2 * Area = x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3 + x1 * y2 - x2 * y1
      Area = 1.0 / 2.0 * (alpha1 + alpha2 + alpha3);
      
      A1 = 2.0 * Area * Xi + Vel_Elxy(2,0) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - Vel_Elxy(2,1) * (Vel_Elxy(1,0) - Vel_Elxy(2,0));

      B1 = Vel_Elxy(1,1) - Vel_Elxy(2,1);
      
      C1 = Vel_Elxy(2,0) - Vel_Elxy(1,0);
      
      A2 = 2.0 * Area * Eta + Vel_Elxy(0,0) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + Vel_Elxy(0,1) * (Vel_Elxy(0,0) - Vel_Elxy(2,0));
      
      B2 = Vel_Elxy(2,1) - Vel_Elxy(0,1);
      
      C2 = Vel_Elxy(0,0) - Vel_Elxy(2,0);
      
      // These are the global coordinates of the gauss point and are constant throughout this loop
      x_Foot = 1.0 / (B1 * C2 - C1 * B2) * ( C2 * A1 - C1 * A2);
      
      y_Foot = 1.0 / (B1 * C2 - C1 * B2) * (B1 * A2 - B2 * A1);

      Y_Old(0) = x_Foot; // Initial Guess is at X
      Y_Old(1) = y_Foot;
      
//       if(Ne == 3)
//       {
// 	std::cout << "HERE!" << endl;
// 	std::cout << "Vel_Elxy = " << Vel_Elxy << endl;
//       }
      
//       std::cout << "Xi = " << Xi << endl;
//       std::cout << "Eta = " << Eta << endl;
//       std::cout << "A1 = " << A1 << endl;
//       std::cout << "A2 = " << A2 << endl;
//       std::cout << "B1 = " << B1 << endl;
//       std::cout << "B2 = " << B2 << endl;
//       std::cout << "C1 = " << C1 << endl;
//       std::cout << "C2 = " << C2 << endl;
//       std::cout << "Area = " << Area << endl;
//       std::cout << "x_Foot = " << x_Foot << endl;
//       std::cout << "y_Foot = " << y_Foot << endl;
// 
//       int J;
//       std::cin >> J;

      Ini_Depart_Feet(Gauss_Pt, 0) = x_Foot;
      Ini_Depart_Feet(Gauss_Pt, 1) = y_Foot;

      Shape2d(Xi,
	      Eta,
	      Vel_Elxy,
	      Vel_Npe,
	      Vel_Flag,
	      Sf,	// output
	      Gdsf,	// output
	      DetJ);	// output

//       std::cout << "Sf = " << Sf << endl;
//       std::cout << "Gdsf = " << Gdsf << endl;
//       std::cout << "DetJ = " << DetJ << endl;
//       int J;
//       std::cin >> J;
      
      // Zero out data structures for use of += later.
      for(int i = 0; i <= 1; i++)
      {
	for(int j = 0; j <= 1; j++)
	{
	  Grad_Vel(i,j) = 0.0;
	}
	It_Vel(i) = 0.0;
      }
      
      // Grad_Vel = El_Vel * Gdsf' (transpose)
      for(int i = 0; i <= 1; i++)
      {
	for(int j = 0; j <= 1; j++)
	{
	  for(int k = 0; k <= Vel_Npe-1; k++)
	  {
	    Grad_Vel(i,j) += El_Vel(i,k) * Gdsf(j,k); // Gdsf transpose
	  }
	}
      }
      
      // Iteratived velocity It_Vel = El_Vel * Sf
      for(int j = 0; j <= Vel_Npe - 1; j++)
      {
	It_Vel(0) += El_Vel(0,j) * Sf(j);
	It_Vel(1) += El_Vel(1,j) * Sf(j);
      }
      
      // Velocity at the Initial Gauss Points
      Ini_Depart_Vel(Gauss_Pt,0) = It_Vel(0);
      Ini_Depart_Vel(Gauss_Pt,1) = It_Vel(1);
      
      Det_Grad_Vel = Grad_Vel(0,0)*Grad_Vel(1,1) - Grad_Vel(0,1)*Grad_Vel(1,0);

      Trace_Grad_Vel = Grad_Vel(0,0) + Grad_Vel(1,1);

      // det(Inv_Grad_Vel)
      Coeff = 1.0 - TIMESTEP / 2.0 * Trace_Grad_Vel + TIMESTEP * TIMESTEP / 4.0 * Det_Grad_Vel;

//       std::cout << "Grad_Vel = " << Grad_Vel << endl;
//       std::cout << "It_Vel = " << It_Vel << endl;
//       std::cout << "Det_Grad_Vel = " << Det_Grad_Vel << endl;
//       std::cout << "Trace_Grad_Vel = " << Trace_Grad_Vel << endl;
//       std::cout << "Coeff = " << Coeff << endl;
//       int K;
//       std::cin >> K;
      
      // The invere of gradu times it's determinant
      Det_Inv_Grad_Vel(0,0) = Grad_Vel(1,1);
      Det_Inv_Grad_Vel(0,1) = -Grad_Vel(0,1);
      Det_Inv_Grad_Vel(1,0) = -Grad_Vel(1,0);
      Det_Inv_Grad_Vel(1,1) = Grad_Vel(0,0);
      
//       std::cout << "Det_Inv_Grad_Vel = " << Det_Inv_Grad_Vel << endl;
      
      // Computing I - k/2 * det(gradu)*(gradu Inv)
      A(0,0) = 1.0 - TIMESTEP / 2.0 * Det_Inv_Grad_Vel(0,0);
      A(0,1) = -TIMESTEP / 2.0 * Det_Inv_Grad_Vel(0,1);
      A(1,0) = -TIMESTEP / 2.0 * Det_Inv_Grad_Vel(1,0);
      A(1,1) = 1.0 - TIMESTEP / 2.0 * Det_Inv_Grad_Vel(1,1);
      
//       std::cout << "A = " << A << endl;

      // computing yn + k * u((yn + x)/2) - x
      B(0) = Y_Old(0) + TIMESTEP * It_Vel(0) - x_Foot;
      B(1) = Y_Old(1) + TIMESTEP * It_Vel(1) - y_Foot;
      
//       std::cout << "B = " << B << endl;

      Y_New(0) = Y_Old(0) - 1.0 / Coeff * (A(0,0) * B(0) + A(0,1) * B(1));
      Y_New(1) = Y_Old(1) - 1.0 / Coeff * (A(1,0) * B(0) + A(1,1) * B(1));
      
//       std::cout << "Y_Old = " << Y_Old << endl;
//       std::cout << "Y_New = " << Y_New << endl;
//       int L;
//       std::cin >> L;
      
      // Compute the vector for determining the two norm of the differenece in iteraions
      Y_Norm(0) = Y_New(0) - Y_Old(0);
      Y_Norm(1) = Y_New(1) - Y_Old(1);
      
//       std::cout << "Y_Norm = " << Y_Norm << endl;
      
      // Compute the two norm
      Feet_Tol = Y_Norm.Norm2();// sqrt(Y_Norm(0,0)*Y_Norm(0,0) + Y_Norm(0,1)*Y_Norm(0,1))

//       std::cout << "Feet_Tol = " << Feet_Tol << endl;

      int counter = 0;

      Cur_Ele = Ne + 1; // Element numbering starts at 1 but Ne starts at 0

//       std::cout << "Cur_Ele = " << Cur_Ele << endl;
      
      while (Feet_Tol > TOL && counter <= 10) // converges in at most 5 steps
      {
	counter = counter + 1;

	Y_New_Xi_Eta(0) = 1.0 / (2.0 * Area) * ((Y_New(0) - Vel_Elxy(2,0)) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - 
			(Y_New(1) - Vel_Elxy(2,1)) * (Vel_Elxy(1,0) - Vel_Elxy(2,0)));
      
	Y_New_Xi_Eta(1) = 1.0 / (2.0 * Area) * ((Y_New(0) - Vel_Elxy(0,0)) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + 
			(Y_New(1) - Vel_Elxy(0,1)) * (Vel_Elxy(0,0) - Vel_Elxy(2,0)));
	
// 	std::cout << "Y_New_Xi_Eta = " << Y_New_Xi_Eta << endl;
	
	New_Ele = FeetSearch(Y_New_Xi_Eta,
			 Cur_Ele,
			 Ele_Neigh);
	
// 	std::cout << "New_Ele = " << New_Ele << endl;
// 	int I;
// 	std::cin >> I;
	
	// -1 is the flag written into Ele_Neigh and means that there is no such neighbor in the domain
	if (New_Ele == -1)
	{
	  New_Ele = Cur_Ele;
	  
	  // Keep the departure feet in the domain
	  if(Y_New(0) < 0)
	  {
	    Y_New(0) = 0;
	    std::cout << "Y_New(0) < 0" << endl;
	  }
      
	  if(Y_New(1) < 0)
	  {
	    Y_New(1) = 0;
	    std::cout << "Y_New(1) < 0" << endl;
	  }
      
	  if(Y_New(0) > 1)
	  {
	    Y_New(0) = 1;
	    std::cout << "Y_New(0) > 1" << endl;
	  }
      
	  if(Y_New(1) > 1)
	  {
	    Y_New(1) = 1;
	    std::cout << "Y_New(1) > 1" << endl;
	  }
	}

	if(New_Ele != Cur_Ele)
	{
	  for (int i = 0; i <= Vel_Npe-1; i++) // get global coordinates of local nodes of element NE
	  {
	    Inod = Vel_Nod(New_Ele-1,i)-1;		// Global node number of local node.
	    Vel_Elxy(i,0) = Vel_Glxy(Inod,0);	// x-coordinate of te new element
	    Vel_Elxy(i,1) = Vel_Glxy(Inod,1);	// y-coordinate of the new element
      
	    El_Vel(0,i) = Vel(Inod,0);
	    El_Vel(1,i) = Vel(Inod,1);
	  }
	  Cur_Ele = New_Ele;
	}
	
//  	std::cout << "Vel_Elxy = " << Vel_Elxy << endl;
//  	std::cout << "El_Vel = " << El_Vel << endl;
	
	// Update position vector
	Y_Old = Y_New;
// 	std::cout << "Y_Old = " << Y_Old << endl;
// 	int J;
// 	std::cin >> J;

//  	std::cout << "Y_Old = " << Y_Old << endl;

	// averages the initial position with the new position and converts to barycentrric coordinates
	Xi = 1.0 / (2.0 * Area) * (((Y_New(0) + x_Foot) / 2.0 - Vel_Elxy(2,0)) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - 
		((Y_New(1) + y_Foot) / 2.0 - Vel_Elxy(2,1)) * (Vel_Elxy(1,0) - Vel_Elxy(2,0)));
      
	Eta = 1.0 / (2.0 * Area) * (((Y_New(0) + x_Foot) / 2.0 - Vel_Elxy(0,0)) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + 
		((Y_New(1) + y_Foot) / 2.0 - Vel_Elxy(0,1)) * (Vel_Elxy(0,0) - Vel_Elxy(2,0)));
	
//  	std::cout << "Xi = " << Xi << endl;
//  	std::cout << "Eta = " << Eta << endl;
// 	int M;
// 	std::cin >> M;
	
	Shape2d(Xi, 
		Eta, 
		Vel_Elxy, 
		Vel_Npe, 
		Vel_Flag, 
		Sf, 	// output
		Gdsf,	// output
		DetJ);	// output
	
// 	std::cout << "Sf = " << Sf << endl;
// 	std::cout << "Gdsf = " << Gdsf << endl;
// 	std::cout << "DetJ = " << DetJ << endl;
// 	int N;
// 	std::cin >> N;
      
	for(int i = 0; i <= 1; i++)
	{
	  for(int j = 0; j <= 1; j++)
	  {
	    Grad_Vel(i,j) = 0.0;
	  }
	  It_Vel(i) = 0.0;
	}
      
	for(int i = 0; i <= 1; i++)
	{
	  for(int j = 0; j <= 1; j++)
	  {
	    for(int k = 0; k <= Vel_Npe-1; k++)
	    {
	      Grad_Vel(i,j) += El_Vel(i,k) * Gdsf(j,k);
	    }
	  }
	}
    
	for(int j = 0; j <= Vel_Npe - 1; j++)
	{
	  It_Vel(0) += El_Vel(0,j) * Sf(j);
	  It_Vel(1) += El_Vel(1,j) * Sf(j);
	}
	
	Det_Grad_Vel = Grad_Vel(0,0)*Grad_Vel(1,1) - Grad_Vel(0,1)*Grad_Vel(1,0);
	
	Trace_Grad_Vel = Grad_Vel(0,0) + Grad_Vel(1,1);
      
	Coeff = 1.0 - TIMESTEP / 2.0 * Trace_Grad_Vel + TIMESTEP * TIMESTEP / 4.0 * Det_Grad_Vel;
	
// 	std::cout << "Grad_Vel = " << Grad_Vel << endl;
// 	std::cout << "It_Vel = " << It_Vel << endl;
// 	std::cout << "Det_Grad_Vel = " << Det_Grad_Vel << endl;
// 	std::cout << "Trace_Grad_Vel = " << Trace_Grad_Vel << endl;
// 	std::cout << "Coeff = " << Coeff << endl;
// 	int O;
// 	std::cin >> O;
	
	// The invere of gradu times it's determinant
	Det_Inv_Grad_Vel(0,0) = Grad_Vel(1,1);
	Det_Inv_Grad_Vel(0,1) = -Grad_Vel(0,1);
	Det_Inv_Grad_Vel(1,0) = -Grad_Vel(1,0);
	Det_Inv_Grad_Vel(1,1) = Grad_Vel(0,0);
	
// 	std::cout << "Det_Inv_Grad_Vel = " << Det_Inv_Grad_Vel << endl;
      
	// yold = x for the initializing step I - k/2 * det(gradu)*(gradu Inv)
	A(0,0) = 1.0 - TIMESTEP / 2.0 * Det_Inv_Grad_Vel(0,0);
        A(0,1) = -TIMESTEP / 2.0 * Det_Inv_Grad_Vel(0,1);
        A(1,0) = -TIMESTEP / 2.0 * Det_Inv_Grad_Vel(1,0);
        A(1,1) = 1.0 - TIMESTEP / 2.0 * Det_Inv_Grad_Vel(1,1);
      
// 	std::cout << "A = " << A << endl;
	
	// yn + k * u((yn + x)/2) - x
	B(0) = Y_Old(0) + TIMESTEP * It_Vel(0) - x_Foot;
	B(1) = Y_Old(1) + TIMESTEP * It_Vel(1) - y_Foot;
	
// 	std::cout << "B = " << B << endl;
	
	Y_New(0) = Y_Old(0) - 1.0 / Coeff * (A(0,0) * B(0) + A(0,1) * B(1));
	Y_New(1) = Y_Old(1) - 1.0 / Coeff * (A(1,0) * B(0) + A(1,1) * B(1));
	
// 	std::cout << "Y_Old = " << Y_Old << endl;
// 	std::cout << "Y_New = " << Y_New << endl;
// 	int P;
// 	std::cin >> P;
	
	// Compute the vector for determining the two norm of the differenece in iteraions
	Y_Norm(0) = Y_New(0) - Y_Old(0);
	Y_Norm(1) = Y_New(1) - Y_Old(1);
	
// 	std::cout << "Y_Norm = " << Y_Norm << endl;
	
	// Compute the two norm
	Feet_Tol = Y_Norm.Norm2();
	
// 	std::cout << "Feet_Tol = " << Feet_Tol << endl;

      } // while
      
//       std::cout << "counter = " << counter << endl;
//       
//       if(counter > 10)
//       {
// 	std::cout << "Feet_Tol = " << Feet_Tol << endl;
//       }
      
      Y_New_Xi_Eta(0) = 1.0 / (2.0 * Area) * ((Y_New(0) - Vel_Elxy(2,0)) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - 
			(Y_New(1) - Vel_Elxy(2,1)) * (Vel_Elxy(1,0) - Vel_Elxy(2,0)));
      
      Y_New_Xi_Eta(1) = 1.0 / (2.0 * Area) * ((Y_New(0) - Vel_Elxy(0,0)) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + 
			(Y_New(1) - Vel_Elxy(0,1)) * (Vel_Elxy(0,0) - Vel_Elxy(2,0)));

      // Even though the point converged it may have left the element in so doing
      New_Ele = FeetSearch(Y_New_Xi_Eta,
		       Cur_Ele,
		       Ele_Neigh);

//       std::cout << "Y_New_Xi_Eta = " << Y_New_Xi_Eta << endl;
//       std::cout << "New_Ele = " << New_Ele << endl;
//       int G;
//       std::cin >> G;
      
      if (New_Ele == -1)
      {
	New_Ele = Cur_Ele;
	  
	// Keep the departure feet in the domain
	if(Y_New(0) < 0)
	{
	  Y_New(0) = 0;
	  std::cout << "Y_New(0) < 0" << endl;
	}
      
	if(Y_New(1) < 0)
	{
	  Y_New(1) = 0;
	  std::cout << "Y_New(1) < 0" << endl;
	}
      
	if(Y_New(0) > 1)
	{
	  Y_New(0) = 1;
	  std::cout << "Y_New(0) > 1" << endl;
	}
      
	if(Y_New(1) > 1)
	{
	  Y_New(1) = 1;
	  std::cout << "Y_New(1) > 1" << endl;
	}
      }
      
      if(New_Ele != Cur_Ele)
      {
	for (int i = 0; i <= Vel_Npe-1; i++) // get global coordinates of local nodes of element NE
	{
	  Inod = Vel_Nod(New_Ele-1,i)-1;		// Global node number of local node.
	  Vel_Elxy(i,0) = Vel_Glxy(Inod,0);	// x-coordinate of te new element
	  Vel_Elxy(i,1) = Vel_Glxy(Inod,1);	// y-coordinate of the new element
      
	  El_Vel(0,i) = Vel(Inod,0);
	  El_Vel(1,i) = Vel(Inod,1);
	}
	Cur_Ele = New_Ele;
      }
      
      Y_New_Xi_Eta(0) = 1.0 / (2 * Area) * ((Y_New(0) - Vel_Elxy(2,0)) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - 
			(Y_New(1) - Vel_Elxy(2,1)) * (Vel_Elxy(1,0) - Vel_Elxy(2,0)));
      
      Y_New_Xi_Eta(1) = 1.0 / (2 * Area) * ((Y_New(0) - Vel_Elxy(0,0)) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + 
			(Y_New(1) - Vel_Elxy(0,1)) * (Vel_Elxy(0,0) - Vel_Elxy(2,0)));
      
      Depart_Feet(Gauss_Pt, 0) = Y_New(0);
      Depart_Feet(Gauss_Pt, 1) = Y_New(1);

      // The point may have not left the element but it did move so recompute everything at the new position
      
      Xi = Y_New_Xi_Eta(0);
      Eta = Y_New_Xi_Eta(1);
      
      Shape2d(Xi, 
	      Eta, 
	      Vel_Elxy, 
	      Vel_Npe, 
	      Vel_Flag, 
	      Sf, 	// output
	      Gdsf, 	// output
	      DetJ);	// output

      for(int i = 0; i <= 1; i++)
      {
	It_Vel(i) = 0.0;
      }
      
      for(int j = 0; j <= Vel_Npe - 1; j++)
      {
	It_Vel(0) += El_Vel(0,j) * Sf(j);
	It_Vel(1) += El_Vel(1,j) * Sf(j);
      }

      Depart_Vel(Gauss_Pt,0) = It_Vel(0);
      Depart_Vel(Gauss_Pt,1) = It_Vel(1);
      
      // Compute the stress at the departure foot
      for (int i = 0; i <= Pre_Npe - 1; i++) 	// get global coordinates of local nodes of element NE
      {
	Inod = Pre_Nod(Cur_Ele-1,i) - 1;	// Global node number (minus one for C++ indexing) of local node.
	Str_Elxy(i,0) = Pre_Glxy(Inod,0);	// x-coordinate
	Str_Elxy(i,1) = Pre_Glxy(Inod,1);	// y-coordinate
      
	El_Str(0,i) = Str(Inod,0);
	El_Str(1,i) = Str(Inod,1);
	El_Str(2,i) = El_Str(1,i); // The stress tensor is symmetric
	El_Str(3,i) = Str(Inod,2);
      }

      Shape2d(Xi, 
	      Eta, 
	      Str_Elxy, 
	      Pre_Npe, 	// Both stress and pressure are linear
	      Pre_Flag, 
	      Str_Sf, 	// output
	      Str_Gdsf, // output
	      DetJ);	// output

      for(int i = 0; i <= 2; i++)
      {
	It_Str(i) = 0.0;
      }
      
      for(int j = 0; j <= Pre_Npe - 1; j++)
      {
	It_Str(0) += El_Str(0,j) * Str_Sf(j);
	It_Str(1) += El_Str(1,j) * Str_Sf(j);
	It_Str(2) += El_Str(3,j) * Str_Sf(j); // Since the Str is symmetric
      }
      
      Depart_Str(Gauss_Pt,0) = It_Str(0);
      Depart_Str(Gauss_Pt,1) = It_Str(1);
      Depart_Str(Gauss_Pt,2) = It_Str(2);
    } // for NI
  } // for NE

//   std::cout << "Ini_Depart_Vel = " << Ini_Depart_Vel << endl;
//   std::cout << "Depart_Vel = " << Depart_Vel << endl;
//   std::cout << "Ini_Depart_Str = " << Ini_Depart_Str << endl;
//   std::cout << "Depart_Str = " << Depart_Str << endl;
//   std::cout << "Ini_Depart_Feet = " << Ini_Depart_Feet << endl;
//   std::cout << "Depart_Feet = " << Depart_Feet << endl;
//   int I;
//   std::cin >> I;

}
