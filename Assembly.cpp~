// Assembles the solution matrix and the RHS

// U_Feet is NNMX3 where each row is the global node number the departure foot is assocaited 
// with and the entires in the row are the x,y coordinates of the departure foot followed by 
// the ellemnt the foot is located in

// A and F come in initialized to zeros

// !!!!!!!!!!!!! add sparse matrix utilization!!!!!!!!!!!!

#include "Shape2d.h"
#include "DepartureFoot.h"
#include "Assembly.h"
#include "Epetra_SerialDenseMatrix.h"
#include "Epetra_IntSerialDenseMatrix.h"
#include "Epetra_SerialDenseVector.h"

#include "Epetra_Map.h"
#include "Epetra_Vector.h"
#include "Epetra_CrsMatrix.h"

typedef Epetra_SerialDenseMatrix E_SDM;
typedef Epetra_IntSerialDenseMatrix E_ISDM;
typedef Epetra_SerialDenseVector E_SDV;

typedef Epetra_CrsMatrix E_CM;
typedef Epetra_Map E_Mp;
typedef Epetra_Vector E_V;

void Assembly(double RE, 
	      double NEW_VIS, 
	      double TIMESTEP, 
	      int Vel_Npe, 
	      int Pre_Npe,
	      int Nem, 
	      int N_TRI_QUAD,
	      int Vel_Nnm,
	      int Pre_Nnm,
	      E_ISDM Vel_Nod, 
	      E_ISDM Pre_Nod, 
	      E_SDM Vel_Glxy, 
	      E_SDM Pre_Glxy, 
	      E_ISDM Ele_Neigh,
	      int VEL_FLAG,
	      int PRE_FLAG, 
	      E_SDM Tri_Quad_Pt, 
	      E_SDV Tri_Quad_Wt, 
	      E_SDM Str, 
	      E_SDM Vel,
	      E_SDM Vel_Old,
	      E_SDM & A, 
	      E_SDV & F) {
  
  // Velocity variables
  E_SDM Vel_Elxy, Vel_Gdsf;
  E_SDV Vel_Sf, Depart_Vel;
  E_SDM El_Vel;
  E_SDV It_Vel;
  int Vel_Inod;
  
  // Pressure variables
  E_SDM Pre_Elxy, Pre_Gdsf;
  E_SDV Pre_Sf;
  int Pre_Inod;
    
  // Stress variables
  E_SDM El_Str; // Stress on a particular element
  E_SDV Gp_Str; // Stress at a particular Gauss point
  
  // Other variables
  E_SDM A11, A12, A22, B1, B2, Dep_Gdsf;
  E_SDV F1, F2, Ini_Foot, Depart_Foot, Y_New_Xi_Eta, Dep_Sf;
  int jj, ii, New_Ele, Inod;//, Gauss_Pt_Num, Cur_Ele;
  double Xi, Eta, a00, a11, a22, DetJ, Const;
  double alpha1, alpha2, alpha3, Two_Area;
  double a1, a2, b1, b2, c1, c2, x_Foot, y_Foot;
  
  El_Vel.Shape(2,Vel_Npe);
  It_Vel.Size(2);
  A11.Shape(Vel_Nnm, Vel_Nnm);
  A12.Shape(Vel_Nnm, Vel_Nnm);
  A22.Shape(Vel_Nnm, Vel_Nnm);
  B1.Shape(Vel_Nnm, Pre_Nnm);
  B2.Shape(Vel_Nnm, Pre_Nnm);
  F1.Size(Vel_Nnm);
  F2.Size(Vel_Nnm);
  Ini_Foot.Size(2);
  Depart_Foot.Size(2);
  Depart_Vel.Size(2);
  Y_New_Xi_Eta.Size(2);

  for(int i = 0; i <= Vel_Nnm-1; i++)
  {
    for(int j = 0; j <= Vel_Nnm-1; j++)
    {
     A11(i,j) = 0.0;
    }
    
    F1(i) = 0.0;
    
    for(int j = 0; j <= Pre_Nnm-1; j++)
    {
      B1(i,j) = 0.0;
    }
  }
  
  A12 = A11;
  A22 = A11;
  F2 = F1;
  B2 = B1;

  // Initialize
  // Velocity terms
  Vel_Elxy.Shape(Vel_Npe,2);
  Vel_Sf.Size(Vel_Npe);  		// value of shape functions at (Xi,Eta)
  Vel_Gdsf.Shape(2,Vel_Npe); 		// derivatives w.r.t. global cooridinates
  
  // Pressure terms
  Pre_Elxy.Shape(Pre_Npe,2);
  Pre_Sf.Size(Pre_Npe);  		// value of shape functions at (Xi,Eta)
  Pre_Gdsf.Shape(2,Pre_Npe); 		// derivatives w.r.t. global cooridinates
  
  // Stress terms
  El_Str.Shape(4,3);
  Gp_Str.Size(3);			// Stress at a Gauss point
  
  // Other terms
  Dep_Gdsf.Shape(2,Vel_Npe);
  Dep_Sf.Size(Vel_Npe);
  
  // PDE coefffiecients
  // I recycle these variables in the calculation below
  a00 = RE / TIMESTEP;
  a11 = NEW_VIS;
  a22 = a11 / 2.0;

  for (int Ne = 0; Ne <= Nem - 1; Ne++) 		// loop over all the elements
  {
    for (int i = 0; i <= Vel_Npe - 1; i++) 	// get global coordinates of local nodes of element Ne
    {
      Vel_Inod = Vel_Nod(Ne,i) - 1;		// Global node number (minus one for indeXing) of local node.
      Vel_Elxy(i,0) = Vel_Glxy(Vel_Inod,0);	// x-coordinate of the velcity
      Vel_Elxy(i,1) = Vel_Glxy(Vel_Inod,1);	// y-coordinate
      
      El_Vel(0,i) = Vel_Old(Vel_Inod,0);
      El_Vel(1,i) = Vel_Old(Vel_Inod,1);
    }

    for (int i = 0; i <= Pre_Npe-1; i++) 	// get global coordinates of local nodes of element Ne
    {
      Pre_Inod = Pre_Nod(Ne,i)-1;		// Global node number (minus one for indeXing) of local node.
      Pre_Elxy(i,0) = Pre_Glxy(Pre_Inod,0);	// x-coordinate of the pressure
      Pre_Elxy(i,1) = Pre_Glxy(Pre_Inod,1);	// y-coordinate
      
      El_Str(0,i) = Str(Pre_Inod,0);
      El_Str(1,i) = Str(Pre_Inod,1);
      El_Str(2,i) = Str(Pre_Inod,1); // The Stress is symmetric
      El_Str(3,i) = Str(Pre_Inod,2);
    }

    for (int Ni = 0; Ni <= N_TRI_QUAD-1; Ni++) // loop over quadrature points
    {
      Xi  = Tri_Quad_Pt(Ni,0);
      Eta = Tri_Quad_Pt(Ni,1);

      Shape2d(Xi, 
	      Eta, 
	      Vel_Elxy, 
	      Vel_Npe, 
	      VEL_FLAG, 
	      Vel_Sf, 		// output
	      Vel_Gdsf,		// output
	      DetJ);	// output

      Shape2d(Xi, 
	      Eta, 
	      Pre_Elxy, 
	      Pre_Npe, 
	      PRE_FLAG, 
	      Pre_Sf, 		// output
	      Pre_Gdsf,		// output
	      DetJ);		// output
	
      // Constant from change of variables, scaled and multiplied by the Gauss weight, see page 559
      Const = 0.5 * Tri_Quad_Wt(Ni) * DetJ;  // These two are the same and can be reduced to one term

      // Zero out data structure for the stress at the Gauss points
      for(int i = 0; i <= Pre_Npe - 1; i++)
      {
	Gp_Str(i) = 0.0;
      }

      // Stress at a Guass point
      for(int j = 0; j <= Pre_Npe - 1; j++)
      {
	Gp_Str(0) += El_Str(0,j) * Pre_Sf(j);
	Gp_Str(1) += El_Str(1,j) * Pre_Sf(j);
	Gp_Str(2) += El_Str(3,j) * Pre_Sf(j);
      }

	// Convert the gauss point into cartesian coordinates for the associated element.
	// In general: 2 * Area = x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3 + x1 * y2 - x2 * y1
	alpha1 = Vel_Elxy(1,0) * Vel_Elxy(2,1) - Vel_Elxy(2,0) * Vel_Elxy(1,1); // x2 * y3 - x3 * y2
	alpha2 = Vel_Elxy(2,0) * Vel_Elxy(0,1) - Vel_Elxy(0,0) * Vel_Elxy(2,1); // x3 * y1 - x1 * y3
	alpha3 = Vel_Elxy(0,0) * Vel_Elxy(1,1) - Vel_Elxy(1,0) * Vel_Elxy(0,1); // x1 * y2 - x2 * y1
	
	Two_Area = alpha1 + alpha2 + alpha3;
      
	a1 = Two_Area * Xi + Vel_Elxy(2,0) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - Vel_Elxy(2,1) * (Vel_Elxy(1,0) - Vel_Elxy(2,0));

        b1 = Vel_Elxy(1,1) - Vel_Elxy(2,1);
      
        c1 = Vel_Elxy(2,0) - Vel_Elxy(1,0);
      
        a2 = Two_Area * Eta + Vel_Elxy(0,0) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + Vel_Elxy(0,1) * (Vel_Elxy(0,0) - Vel_Elxy(2,0));
      
        b2 = Vel_Elxy(2,1) - Vel_Elxy(0,1);
      
        c2 = Vel_Elxy(0,0) - Vel_Elxy(2,0);
      
        // These are the global coordinates of the gauss point and are constant throughout this loop
        x_Foot = 1.0 / (b1 * c2 - c1 * b2) * (c2 * a1 - c1 * a2);
      
        y_Foot = 1.0 / (b1 * c2 - c1 * b2) * (b1 * a2 - b2 * a1);
	
	Ini_Foot(0) = x_Foot;
	Ini_Foot(1) = y_Foot;

	DepartureFoot(VEL_FLAG, 
		      Ne, 
		      TIMESTEP,
		      Vel_Old, 
		      Vel_Glxy, 
		      Vel_Npe, 
		      Vel_Nod, 
		      Ele_Neigh,
		      Ini_Foot,		// in x,y space
		      Depart_Foot,	// output in x,y space
		      New_Ele);		// output

	if(New_Ele-1 != Ne)
	{
	  for (int k = 0; k <= Vel_Npe-1; k++) // get global coordinates of local nodes of element NE
	  {
	    Inod = Vel_Nod(New_Ele-1,k)-1;		// Global node number of local node.
	    Vel_Elxy(k,0) = Vel_Glxy(Inod,0);	// x-coordinate of te new element
	    Vel_Elxy(k,1) = Vel_Glxy(Inod,1);	// y-coordinate of the new element
      
	    El_Vel(0,k) = Vel_Old(Inod,0);
	    El_Vel(1,k) = Vel_Old(Inod,1);
	  }
	}

      // Convert the cartesian coordinates to barycentric coordinates
      alpha1 = Vel_Elxy(1,0) * Vel_Elxy(2,1) - Vel_Elxy(2,0) * Vel_Elxy(1,1); // x2 * y3 - x3 * y2
      alpha2 = Vel_Elxy(2,0) * Vel_Elxy(0,1) - Vel_Elxy(0,0) * Vel_Elxy(2,1); // x3 * y1 - x1 * y3
      alpha3 = Vel_Elxy(0,0) * Vel_Elxy(1,1) - Vel_Elxy(1,0) * Vel_Elxy(0,1); // x1 * y2 - x2 * y1
      
      Two_Area = alpha1 + alpha2 + alpha3;
      
      Y_New_Xi_Eta(0) = 1.0 / Two_Area * ((Depart_Foot(0) - Vel_Elxy(2,0)) * (Vel_Elxy(1,1) - Vel_Elxy(2,1)) - 
			(Depart_Foot(1) - Vel_Elxy(2,1)) * (Vel_Elxy(1,0) - Vel_Elxy(2,0)));
      
      Y_New_Xi_Eta(1) = 1.0 / Two_Area * ((Depart_Foot(0) - Vel_Elxy(0,0)) * (Vel_Elxy(2,1) - Vel_Elxy(0,1)) + 
			(Depart_Foot(1) - Vel_Elxy(0,1)) * (Vel_Elxy(0,0) - Vel_Elxy(2,0)));

      //The point may have not left the element but it did move so recompute everything at the new position
      Xi = Y_New_Xi_Eta(0);
      Eta = Y_New_Xi_Eta(1);

      Shape2d(Xi, 
	      Eta, 
	      Vel_Elxy, 
	      Vel_Npe, 
	      VEL_FLAG, 
	      Dep_Sf, 	// output
	      Dep_Gdsf, // output
	      DetJ);	// output

      for(int k = 0; k <= 1; k++)
      {
	It_Vel(k) = 0.0;
      }
      
      for(int k = 0; k <= Vel_Npe - 1; k++)
      {
	It_Vel(0) += El_Vel(0,k) * Dep_Sf(k);
	It_Vel(1) += El_Vel(1,k) * Dep_Sf(k);
      }

      Depart_Vel(0) = It_Vel(0);
      Depart_Vel(1) = It_Vel(1);

      // Matrix and RHS calculations; element by element
      for (int i = 0; i <= Vel_Npe-1; i++)
      {
	ii = Vel_Nod(Ne,i) - 1;
	  
	for (int j = 0; j <= Vel_Npe-1; j++)
	{
	  jj = Vel_Nod(Ne,j) - 1;

	  A11(ii,jj) += Const * (a11 * Vel_Gdsf(0,i) * Vel_Gdsf(0,j)
	    + a22 * Vel_Gdsf(1,i) * Vel_Gdsf(1,j) + a00 * Vel_Sf(i) * Vel_Sf(j));

	  A12(ii,jj) += Const * a22 * Vel_Gdsf(0,i) * Vel_Gdsf(1,j);

	  A22(ii,jj) += Const * (a22 * Vel_Gdsf(0,i) * Vel_Gdsf(0,j)
	    + a11 * Vel_Gdsf(1,i) * Vel_Gdsf(1,j) + a00 * Vel_Sf(i) * Vel_Sf(j));

	} // vel j

	F1(ii) += Const * (Vel_Sf(i) * a00 * Depart_Vel(0) - 
	   Vel_Gdsf(0,i) * Gp_Str(0) - Vel_Gdsf(1,i) * Gp_Str(1));

	F2(ii) += Const * (Vel_Sf(i) * a00 * Depart_Vel(1) - 
	   Vel_Gdsf(0,i) * Gp_Str(1) - Vel_Gdsf(1,i) * Gp_Str(2));

	for (int j = 0; j <= Pre_Npe-1; j++)
	{
	  jj = Pre_Nod(Ne,j) - 1;

	  B1(ii,jj) += -Const * Vel_Gdsf(0,i) * Pre_Sf(j);

	  B2(ii,jj) += -Const * Vel_Gdsf(1,i) * Pre_Sf(j);

	} // pre j
      } // vel i
    } // for Ni
  } // for Ne

  // Assembly the velocity and pressure solution matrix
  for (int i = 0; i <= Vel_Nnm-1; i++)
  {
    // Velocity blocks
    for (int j = 0; j <= Vel_Nnm-1; j++)
    {
      A(i,j) = A11(i,j);
      A(i,j + Vel_Nnm) = A12(i,j);
      A(i + Vel_Nnm,j) = A12(j,i); // A21 is the transpose of A12
      A(i + Vel_Nnm,j + Vel_Nnm) = A22(i,j);
    }
    
    // Pressure blocks
    for (int j = 0; j <= Pre_Nnm-1; j++)
    {
      A(i,j + 2 * Vel_Nnm) = B1(i,j);
      A(i + Vel_Nnm,j + 2 * Vel_Nnm) = B2(i,j);
      
      A(j + 2 * Vel_Nnm,i) = B1(i,j);			// B1 transpose
      A(j + 2 * Vel_Nnm,i + Vel_Nnm) = B2(i,j);	// B2 transpose
    }
    // RHS
    F(i) = F1(i);
    F(i + Vel_Nnm) = F2(i);
  }
  
//   for (int i = 0; i <= Pre_Nnm-1; i++)
//   {
// 
//     A(i + 2 * Vel_Nnm, i + 2 * Vel_Nnm) = 0.000001;
// 
//   }
  
}