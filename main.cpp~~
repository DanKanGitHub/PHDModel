// Main program for my 2D FEM model of viscco-elastic fluid flow.

#include "Epetra_ConfigDefs.h"
#ifdef HAVE_MPI
#include "mpi.h"
#include "Epetra_MpiComm.h"
#else
#include "Epetra_SerialComm.h"
#endif

#include "Epetra_SerialDenseVector.h"
#include "Epetra_IntSerialDenseVector.h"
#include "Epetra_SerialDenseMatrix.h"
#include "Epetra_IntSerialDenseMatrix.h"
#include "Epetra_SerialDenseSolver.h"

#include <fstream>
#include "Mesh2d.h"
#include "Mesh2dPreBndry.h"
#include "Mesh2dVelBndry.h"
#include "Boundary2d.h"
#include "Assembly.h"
#include "QuadPtWt.h"
#include "InitialVel.h"
#include "InitialStr.h"
#include "ElementNeigh.h"
#include "Conformation.h"
#include "DepartureInfo.h"

typedef Epetra_SerialDenseMatrix E_SDM;
typedef Epetra_IntSerialDenseMatrix E_ISDM;
typedef Epetra_SerialDenseVector E_SDV;
typedef Epetra_IntSerialDenseVector E_ISDV;

//Constants
const int NX = 2;			// Number of element intervals in the horizontal direction
const int NY = 2;
const int NGP = 4;			// Number of Gauss points in numerical quadrature, used on the boundary
const int N_TRI_QUAD = 4;		// Number of Gauss points in numerical quadrature, used in the element
const int MAX_TIME_STEP_NUM = 100;	// Maximum number of time interations
const int VEL_FLAG = 2;			// Program flags
const int PRE_FLAG = 1;
const double XL = 0.0;			// coordinate of left boundary element
const double XR = 1.0;			// coordinate of right boundary element
const double YB = 0.0;			// Coordinate of the bottom boundary of the domain.
const double YT = 1.0;			// Coordinate of the top boundary of the domain.
const double RE = 1.0;			// Reynold's Number					@@!!!!!What is it!!!!!@@
const double NEW_VIS = 1.0;		// Newtonian Viscosity 					@@!!!!!What is it!!!!!@@
const double TIMESTEP = 1.0;		// Later set Time Step = dx / max_vel / 5
const double TOL = 0.00001;		// Is this good?
const double ALPHA = 1.0;		// !!!What is it!!!
const double BETA = 1.0;		// !!!What is it!!!

int main(int argc, char *argv[])
{
#ifdef HAVE_MPI
  MPI_Init(&argc, &argv);
  Epetra_MpiComm Comm(MPI_COMM_WORLD);
#else
  Epetra_SerialComm Comm;
#endif
  
  // variable decalrations
  // Velocity Related
  // Velocity is NNMX2, Depart_Vel is Gaus_Pt_NumX2
  E_SDM Vel, Vel_New, Vel_Glxy, Depart_Vel;
  E_ISDM Vel_Nod, Vel_Nb_Ele;
  E_SDV Vel_Norm;
  E_ISDV Vel_Eb_Node, Vel_Nb_Edg;
  int Vel_Npe, Vel_Nb_Ele_No, Vel_Eb_Node_No, Vel_Nnm;
  double Vel_Tol;
  
  // Presure Related
  E_SDM Pre_Glxy;
  E_ISDM Pre_Nod, Pre_Nb_Ele, Pre_Nb_Edg;
  E_ISDV Pre_Eb_Node;
  E_SDV Pre, Pre_Norm, Pre_New;
  int Pre_Npe, Pre_Nb_Ele_No, Pre_Eb_Node_No, Pre_Nnm;
  double Pre_Tol;
  
  // There are no essential pressure B.C.s but so that I do not have to write a second Boundary2d program
  // I will still need these variables as input parameters.
  Pre_Eb_Node.Size(1);
  Pre_Eb_Node(0) = 0;
  Pre_Eb_Node_No = 0;
  
  // Stress Related
  // Stess is NNMX3, Depart_Str is Gaus_Pt_NumX3
  E_SDM Str, Str_New, Depart_Str, C;
  E_SDV c1, c2, c3, FC1, FC2, FC3;
  
  // Other
  E_SDM GAUSPT, GAUSWT, Tri_Quad_Pt, AVP, AVPBC;
  E_ISDM Ele_Neigh;
  E_SDV FVP, FVPBC, x, Tri_Quad_Wt;
  int Nem, L, n, Gauss_Pt_Num; // L, n are counters
  double dx, dy;
  
  // Gaussian quadrature points and weights for 1d boundary integration, NGP = 1,2 3, or 4
  // In this code it is intended that NGP = 4
  
  GAUSPT.Shape(4,4);
  GAUSWT.Shape(4,4);
  
  for(int i = 0; i <= 3; i++)
  {
    for(int j = 0; j <= 3; j++)
    {
      GAUSWT(i,j) = 0.0;
      GAUSPT(i,j) = 0.0;
    }
  }
  
  GAUSPT(0,1) = -1.0/sqrt(3);
  GAUSPT(0,3) = 0.33998194;
  GAUSPT(1,1) = 1.0/sqrt(3);
  GAUSPT(1,2) = 0.7745966692;
  GAUSPT(1,3) = -0.33998194;
  GAUSPT(2,2) = -0.7745966692;
  GAUSPT(2,3) = 0.86113631;
  GAUSPT(3,3) = -0.86113631;
  
  GAUSWT(0,0) = 2.0;
  GAUSWT(0,1) = 1.0;
  GAUSWT(0,2) = 8.0/9.0;
  GAUSWT(0,3) = 0.65214515;
  GAUSWT(1,1) = 1.0;
  GAUSWT(1,2) = 5.0/9.0;
  GAUSWT(1,3) = 0.65214515;
  GAUSWT(2,2) = 5.0/9.0;
  GAUSWT(2,3) = 0.34785485;
  GAUSWT(3,3) = 0.34785485;
  
  Nem = 2*NX*NY; // Number of triangular nodes in the mesh.
  
  // Step sizes
  dx = (XR - XL) / NX;	// mesh size in the x direction
  dy = (YT - YB) / NY;	// mesh size in the y direction
  
  // Choose TIMESTEP so small that even at maximum velocity the  Gauss point closest to the edge of an 
  // element cannot move out of that element in a single time step
  if ( dx <= dy)
  {
    TIMESTEP = dx / (3/2) / 5;
  }
  else
  {
    TIMESTEP = dy / (3/2) / 5;
  }
    
  // preprocessor, generate mesh and connectivity matrix
  Mesh2d(dx, 
	 dy,
	 XL,
	 XR,
	 YB, 
	 YT, 
	 NX, 
	 NY, 
	 VEL_FLAG, 
	 Nem, 
	 Vel_Nnm, 	// output
	 Vel_Npe, 	// output
	 Vel_Glxy, 	// output
	 Vel_Nod);	// output
  
  Mesh2d(dx, 
	 dy, 
	 XL, 
	 XR, 
	 YB, 
	 YT, 
	 NX, 
	 NY, 
	 PRE_FLAG, 
	 Nem, 
	 Pre_Nnm, 	// output
	 Pre_Npe, 	// output
	 Pre_Glxy, 	// output
	 Pre_Nod);	// output
  
  // Solution vectors
  x.Size(2*Vel_Nnm + Pre_Nnm); // Velocity and pressure solution vector
  c1.Size(Pre_Nnm);		// Str(1,1) solution vector
  c2.Size(Pre_Nnm);		// Str(1,2) and Str(2,1) by to symmetry solution vector
  c3.Size(Pre_Nnm);		// Str(2,2) solution vector
  
  // Velocity, Pressure and Stress Data
  Vel.Shape(Vel_Nnm,2);
  Pre.Size(Pre_Nnm);
  Str.Shape(Pre_Nnm,3); // Only Pre_Nnm X 3 because the stress is symmetric
  
  for(int i = 0; i <= Vel_Nnm-1; i++)
  {
    
    x(i) = 0.0;
    x(i + Vel_Nnm) = 0.0;
    
    Vel(i,0) = 0.0;
    Vel(i,1) = 0.0;
    
    for(int j = 0; j <= Pre_Nnm-1; j++)
    {
      x(j + 2*Vel_Nnm) = 0.0;
      
      c1(j) = 0.0;
      // c2(j) = 0.0;
      // c3(j) = 0.0;
      
      Pre(j) = 0.0;
      
      Str(j,0) = 0.0;
      Str(j,1) = 0.0;
      Str(j,2) = 0.0;
    }
  }
  
  c2 = c1;
  c3 = c1;
  
  Mesh2dPreBndry(NX, 
		 NY,
		 Pre_Nb_Ele_No,	// output
		 Pre_Nb_Ele, 	// output
		 Pre_Nb_Edg);	// output
  
  Mesh2dVelBndry(NX, 
		 NY,
		 Vel_Nb_Ele_No,	// output
		 Vel_Nb_Ele, 	// output
		 Vel_Nb_Edg, 	// output
		 Vel_Eb_Node_No,// output
		 Vel_Eb_Node);	// output
  
  // Determine intial surfaces and stress tensor nodal values
  InitialVel(Vel_Nnm, 
	     Vel_Glxy, 
	     Vel); // Size Vel_NnmX2, output
  
  // Pressure is initalized to zero
  
  // InitialPre(Pre_Glxy, Pre); // Size Pre_NnmX1, pressure is initialized to zero
  InitialStr(Pre_Nnm, 
	     NEW_VIS, 
	     Pre_Glxy, 
	     Str); // Size Pre_NnmX3, the stress tensor is symmetric, output
  
  // Output file declaration
  std::fstream outFileVelocity;
  outFileVelocity.open("Velocity_DATA_1.txt");
  outFileVelocity << std::fixed;
  outFileVelocity.precision(2);
  outFileVelocity.setf(std::ios_base::showpoint);
  
  std::ofstream outFilePressure;
  outFilePressure.open("Pressure_DATA_1.txt");
  outFilePressure << std::fixed;
  outFilePressure.precision(2);
  outFilePressure.setf(std::ios_base::showpoint);
  
  std::ofstream outFileStress;
  outFileStress.open("Stress_DATA_1.txt");
  outFileStress << std::fixed;
  outFileStress.precision(2);
  outFileStress.setf(std::ios_base::showpoint);
      
  // Output data to file
  outFileVelocity << Vel << endl;
  outFilePressure << Pre << endl;
  outFileStress << Str << endl;
  
  // There are at most 3 neightbors in my triangular mesh.
  Ele_Neigh.Shape(Nem,3);
  for(int i = 0; i <= Nem-1; i++)
  {
    Ele_Neigh(i,0) = 0.0;
    Ele_Neigh(i,1) = 0.0;
    Ele_Neigh(i,2) = 0.0;
  }
  
  // Determine which global elements share each side of each element
  ElementNeigh(Nem,
	       NX,
	       Ele_Neigh);	// output
  
  //The points and weights for quadrature on a triangle element in barycentric coordinates.
  QuadPtWt(N_TRI_QUAD,
	   Tri_Quad_Pt,
	   Tri_Quad_Wt);
  
  Gauss_Pt_Num = Nem*N_TRI_QUAD; // No Gauss points are shared
  
  Depart_Vel.Shape(Gauss_Pt_Num,2);
  Depart_Str.Shape(Gauss_Pt_Num,3);
  
  for(int i = 0; i <= Gauss_Pt_Num-1; i++)
  {
    Depart_Vel(i,0) = 0.0;
    Depart_Vel(i,1) = 0.0;
    
    Depart_Str(i,0) = 0.0;
    Depart_Str(i,1) = 0.0;
    Depart_Str(i,2) = 0.0;
  }

  // Determine the departure feet
  DepartureInfo(VEL_FLAG,
		PRE_FLAG, 
		N_TRI_QUAD, 
		Nem, 
		Tri_Quad_Pt, 
		TIMESTEP, 
		Vel, 
		Str, 
		Vel_Glxy, 
		Pre_Glxy, 
		Vel_Npe, 
		Pre_Npe, 
		Vel_Nod, 
		Pre_Nod, 
		Ele_Neigh, 
		Depart_Vel, 	// output
		Depart_Str);	// output

  // Initialize counter
  L = 0;
  
  // Initialize tolerances
  Vel_Tol = 1.0;
  Pre_Tol = 1.0;
  
  // Initialize the sizes of the LHS matrices and RHS vectors
  AVP.Shape(2*Vel_Nnm + Pre_Nnm, 2*Vel_Nnm + Pre_Nnm);
  FVP.Size(2*Vel_Nnm + Pre_Nnm);
    
  FC1.Size(Pre_Nnm);
  FC2.Size(Pre_Nnm);
  FC3.Size(Pre_Nnm);
  C.Shape(Pre_Nnm, Pre_Nnm);
  
  AVPBC.Shape(2*Vel_Nnm + Pre_Nnm, 2*Vel_Nnm + Pre_Nnm);
  FVPBC.Size(2*Vel_Nnm + Pre_Nnm);
  
  Vel_Norm.Size(2*Vel_Nnm);
  Pre_Norm.Size(Pre_Nnm);
  
  // Initialize the LHS matrices and RHS vectors to zero
  for(int i = 0; i <= Vel_Nnm-1; i++)
  {
    for(int j = 0; j <= Vel_Nnm-1; j++)
    {
      AVP(i , j) = 0.0;
      AVP(i , j + Vel_Nnm) = 0.0;
      AVP(i + Vel_Nnm , j) = 0.0;
      AVP(i + Vel_Nnm , j + Vel_Nnm) = 0.0;
      AVP(i , j + 2 * Vel_Nnm) = 0.0;
    }
    
    FV(i) = 0.0;
    FV(i + Vel_Nnm) = 0.0;
    
    for(int k = 0; k <= Pre_Nnm-1; k++)
    {
      AVP(k + 2 * Vel_Nnm , i) = 0.0;
      AVP(i + Vel_Nnm , k + 2 * Vel_Nnm) = 0.0;
      AVP(k + 2 * Vel_Nnm , i + Vel_Nnm) = 0.0;
      AVP(k + 2 * Vel_Nnm , k + 2 * Vel_Nnm) = 0.0;
      FVP(k + 2 * Vel_Nnm) = 0.0;
      FC1(k) = 0.0; 
    }
  }
  
  for(int i = 0; i <= Pre_Nnm-1; i++)
  {
    for(int j = 0; j <= Pre_Nnm-1; j++)
    {
      C(i , j) = 0.0;
      C(i , j + Pre_Nnm) = 0.0;
      C(i + Pre_Nnm , j) = 0.0;
      C(i + Pre_Nnm , j + Pre_Nnm) = 0.0;
    }
  }
  
  AVPBC = AVP;
  FVPBC = FVP;
  
  FC2 = FC1;
  FC3 = FC1;
  
  while (Vel_Tol > TOL || Pre_Tol > TOL)
  {
    // Assembles the complete matrix for velocity and pressure and its solution vector
    Assembly(RE, 
	     NEW_VIS, 
	     TIMESTEP, 
	     Vel_Npe, 
	     Pre_Npe, 
	     Nem,
	     N_TRI_QUAD,
	     Vel_Nnm,
	     Pre_Nnm,
	     Vel_Nod, 
	     Pre_Nod, 
	     Vel_Glxy, 
	     Pre_Glxy, 
	     VEL_FLAG, 
	     PRE_FLAG, 
	     Tri_Quad_Pt, 
	     Tri_Quad_Wt, 
	     Str, 
	     Vel, 
	     Depart_Vel, 
	     AVP, 	// output
	     FVP);	// output
    
    AVPBC = AVP;
    FVPBC = FVP;
    
    // Includes the boundary conditions into the assembled matrix
    Boundary2d(GAUSPT, 
	       GAUSWT, 
	       NX,
	       NY,
	       VEL_FLAG,
	       NGP, 
	       Vel_Nnm,
	       Pre_Nnm,
	       Vel_Glxy, 
	       Vel_Nod,
	       Vel_Nb_Ele_No, 
	       Vel_Nb_Ele, 
	       Vel_Nb_Edg,
	       Vel_Eb_Node_No, 
	       Vel_Eb_Node, 
	       AVPBC, 	// output
	       FVPBC);	// output
    
    Boundary2d(GAUSPT, 
	       GAUSWT, 
	       NX,
	       NY,
	       PRE_FLAG,
	       NGP,
	       Vel_Nnm,
	       Pre_Nnm,
	       Pre_Glxy, 
	       Pre_Nod,
	       Pre_Nb_Ele_No, 
	       Pre_Nb_Ele, 
	       Pre_Nb_Edg,
	       Pre_Eb_Node_No, 
	       Pre_Eb_Node, 
	       AVPBC, 	// output
	       FVPBC);	// output
    
    // set up the solver
    Epetra_SerialDenseSolver Vel_Problem;
    Vel_Problem.SetMatrix( AVPBC );
    Vel_Problem.SetVectors( x, FVPBC );
    Vel_Problem.Solve();
    
    for (int i = 0; i <= Vel_Nnm-1; i++)
    {
      Vel_New(i,0) = x(i);
      Vel_New(i,1) = x(i+Vel_Nnm);
      
      Vel_Norm(i) = x(i) - Vel(i,0);
      Vel_Norm(i + Vel_Nnm) = x(i+Vel_Nnm) - Vel(i,1);
    }
    
    for (int i = 0; i <= Pre_Nnm-1; i++)
    {
      Pre_New(i) = x(i+2*Vel_Nnm);
      Pre_Norm(i) = Pre_New(i) - Pre(i);
    }
    
    // Determine the stress tensor.  Need the solver written
    Conformation(TIMESTEP,
		 ALPHA, 
		 BETA, 
		 Vel_Npe, 
		 Pre_Npe, 
		 Nem, 
		 N_TRI_QUAD,
		 Pre_Nnm,
		 Vel_Nod, 
		 Pre_Nod, 
		 Vel_Glxy, 
		 Pre_Glxy, 
		 Tri_Quad_Pt, 
		 Tri_Quad_Wt, 
		 VEL_FLAG, 
		 PRE_FLAG, 
		 Vel_New, 
		 Str, 
		 Depart_Str, 
		 C, 	// output
		 FC1,	// output
		 FC2,	// output
		 FC3);	// output
    
    //Solve(F, D, Str_New);
    Epetra_SerialDenseSolver Str_Problem1;
    Str_Problem1.SetMatrix( C );
    Str_Problem1.SetVectors( c1, FC1 );
    Str_Problem1.Solve();
    
    Epetra_SerialDenseSolver Str_Problem2;
    Str_Problem2.SetMatrix( C );
    Str_Problem2.SetVectors( c2, FC2 );
    Str_Problem2.Solve();
    
    Epetra_SerialDenseSolver Str_Problem3;
    Str_Problem3.SetMatrix( C );
    Str_Problem3.SetVectors( c3, FC3 );
    Str_Problem3.Solve();
    
    for (int i = 0; i <= Pre_Nnm-1; i++)
    {
      Str_New(i,0) = c1(i);
      Str_New(i,1) = c2(i);
      Str_New(i,2) = c3(i); // Skip the redundant section of c
    }
    
    // Compute the tolerance check values
    Vel_Tol = Vel_Norm.Norm2();
    Pre_Tol = Pre_Norm.Norm2();
    
    // Update the iteration variables
    Vel = Vel_New;
    Pre = Pre_New;
    Str = Str_New;
    
    // Iterate counter
    L = L + 1;
  }

  // Output data to file
  outFileVelocity << Vel << endl;
  outFilePressure << Pre << endl;
  outFileStress << Str << endl;
  // Initialize time counter
  n = 1;
  
  while (n <=MAX_TIME_STEP_NUM)
  {
    // Determine the departure feet
    DepartureInfo(VEL_FLAG, 
		  PRE_FLAG, 
		  N_TRI_QUAD, 
		  Nem, 
		  Tri_Quad_Pt, 
		  TIMESTEP, 
		  Vel, Str,  
		  Vel_Glxy, 
		  Pre_Glxy, 
		  Vel_Npe, 
		  Pre_Npe, 
		  Vel_Nod, 
		  Pre_Nod, 
		  Ele_Neigh, 
		  Depart_Vel, 
		  Depart_Str);
  
    // Initialize counter
    L = 0;
  
    // Initialize tolerances
    Vel_Tol = 1.0;
    Pre_Tol = 1.0;
    
    while (Vel_Tol > TOL || Pre_Tol > TOL)
    {
      // Assembles the complete matrix for velocity and pressure and its solution vector
      Assembly(RE, 
	       NEW_VIS, 
	       TIMESTEP, 
	       Vel_Npe, 
	       Pre_Npe, 
	       Nem, 
	       N_TRI_QUAD,
	       Vel_Nnm,
	       Pre_Nnm,
	       Vel_Nod, 
	       Pre_Nod, 
	       Vel_Glxy, 
	       Pre_Glxy, 
	       VEL_FLAG, 
	       PRE_FLAG, 
	       Tri_Quad_Pt, 
	       Tri_Quad_Wt, 
	       Str, 
	       Vel, 
	       Depart_Vel, 
	       AVP, 
	       FVP);
      
      AVPBC = AVP;
      FVPBC = FVP;
      
      // Includes the boundary conditions into the assembled matrix
      Boundary2d(GAUSPT, 
	         GAUSWT, 
		 NX,
		 NY,
	         VEL_FLAG,
	         NGP, 
	         Vel_Nnm,
	         Pre_Nnm,
	         Vel_Glxy, 
	         Vel_Nod,
	         Vel_Nb_Ele_No, 
	         Vel_Nb_Ele, 
	         Vel_Nb_Edg,
	         Vel_Eb_Node_No, 
	         Vel_Eb_Node, 
	         AVPBC, 
	         FVPBC);
    
      Boundary2d(GAUSPT, 
		 GAUSWT, 
	         PRE_FLAG,
	         NGP,
	         Vel_Nnm,
	         Pre_Nnm,
	         Pre_Glxy, 
	         Pre_Nod,
	         Pre_Nb_Ele_No, 
	         Pre_Nb_Ele, 
	         Pre_Nb_Edg,
	         Pre_Eb_Node_No, 
	         Pre_Eb_Node, 
	         AVPBC, 
	         FVPBC);

      // Solves the system
      Epetra_SerialDenseSolver Vel_Problem;
      Vel_Problem.SetMatrix( AVPBC );
      Vel_Problem.SetVectors( x, FVPBC );
      Vel_Problem.Solve();
    
      for (int i = 0; i <= Vel_Nnm-1; i++)
      {
	Vel_New(i,0) = x(i);
	Vel_New(i,1) = x(i+Vel_Nnm);
	
	Vel_Norm(i) = x(i) - Vel(i,0);
	Vel_Norm(i + Vel_Nnm) = x(i+Vel_Nnm) - Vel(i,1);
      }
    
      for (int i = 0; i <= Pre_Nnm-1; i++)
      {
	Pre_New(i) = x(i+2*Vel_Nnm);
	Pre_Norm(i) = Pre_New(i) - Pre(i);
      }
      
      // Determine the stress tensor.
      Conformation(TIMESTEP,
		   ALPHA, 
		   BETA, 
		   Vel_Npe, 
		   Pre_Npe, 
		   Nem, 
		   N_TRI_QUAD,
		   Pre_Nnm,
		   Vel_Nod, 
		   Pre_Nod, 
		   Vel_Glxy, 
		   Pre_Glxy, 
		   Tri_Quad_Pt, 
		   Tri_Quad_Wt, 
		   VEL_FLAG, 
		   PRE_FLAG, 
		   Vel_New, 
		   Str, 
		   Depart_Str, 
		   C, 
		   FC1,
		   FC2,
		   FC3);
    
      //Solve(F, D, Str_New);
      Epetra_SerialDenseSolver Str_Problem1;
      Str_Problem1.SetMatrix( C );
      Str_Problem1.SetVectors( c1, FC1 );
      Str_Problem1.Solve();
      
      Epetra_SerialDenseSolver Str_Problem2;
      Str_Problem2.SetMatrix( C );
      Str_Problem2.SetVectors( c2, FC2 );
      Str_Problem2.Solve();
      
      Epetra_SerialDenseSolver Str_Problem3;
      Str_Problem3.SetMatrix( C );
      Str_Problem3.SetVectors( c3, FC3 );
      Str_Problem3.Solve();
    
      for (int i = 0; i <= Pre_Nnm-1; i++)
      {
	Str_New(i,0) = c1(i);
	Str_New(i,1) = c2(i);
	Str_New(i,2) = c3(i); // Skip the redundant section of c
      }
      
      // Compute the tolerance check values
      Vel_Tol = Vel_Norm.Norm2();
      Pre_Tol = Pre_Norm.Norm2();
    
      // Update the iteration variables
      Vel = Vel_New;
      Pre = Pre_New;
      Str = Str_New;
    
      // Iterate counter
      L = L + 1;
    } // L while loop
    
    n = n + 1;
    
    // Output data to file
    outFileVelocity << Vel << endl;
    outFilePressure << Pre << endl;
    outFileStress << Str << endl;
    
  } // n while loop
  
  // Close the output files
  outFileVelocity.close();
  outFilePressure.close();
  outFileStress.close();
  
  return 0;
}