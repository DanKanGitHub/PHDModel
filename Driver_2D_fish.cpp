#include "Driver.h"#define PI (3.14159265359) //************************************************************************************************************************//member function of class Global_Parameter, note here the global variables are defined//in DataStruct.cc, and they are the non-dimensionalized parametersvoid Global_Parameter::To_Nondimension(const Control_Parameter& CP) {  double rho_0, c_0, h, t_0;  double t_rh2, t2_rh4, r_t, t2_rh2, t_h2;  rho_0 = CP.rho_0;  c_0 = CP.c_0;  h = CP.h;  t_0 = CP.t_0;  t_rh2  = t_0/rho_0/h/h;  t2_rh4 = t_0*t_0/rho_0/h/h/h/h;  r_t    = rho_0/t_0;  t2_rh2 = t_0*t_0/rho_0/h/h;  t_h2   = t_0/h/h;  Gamma_1 = gam_1*KB*T*t2_rh4;  Gamma_2 = gam_2*KB*T*t2_rh2;  Kai_CH = kai_CH;  NP_inv = np_inv;  PHI_reg = phi_reg;  Lambda = lam*r_t;  sub_epsilon = s_eps;  sub_mu = s_mu*t_0;  sub_K_c = s_K_c/c_0;  sub_A = s_A*t_0;  Ds = ds*t_h2;  eta_net = eta_n*t_rh2;  eta_sol = eta_s*t_rh2;  rho_net = rho_n/rho_0;  rho_sol = rho_s/rho_0;  eta_ave = .1*eta_net + .9*eta_sol;  //average viscosity}//************************************************************************************************************************//function to read in the global physical parameters, such Gamma_1, Gamma_2, Kai, eta_n, eta_s, rho_n, rho_s, ....void Read_Global_Parameters(char* filename, Global_Parameter& GP, const Control_Parameter& CP){  ifstream ifile(filename, ios::in);  if( !ifile)    {      cout << " \n\t Can not open the global parameters file " << filename << " !! " << endl;      exit(-1);    }  char datacomment[200];  ifile  >> datacomment >> GP.KB         //KB         >> datacomment >> GP.T          //Temperature         >> datacomment >> GP.gam_1      // Gamma_1         >> datacomment >> GP.gam_2      //Gamma_2         >> datacomment >> GP.kai_CH     //Kai_CH         >> datacomment >> GP.np_inv     //NP_in         >> datacomment >> GP.phi_reg    //PHI_reg         >> datacomment >> GP.lam        //Lambda         >> datacomment >> GP.s_eps      //epsilon         >> datacomment >> GP.s_mu       //sub_mu         >> datacomment >> GP.s_K_c      //sub_K_c         >> datacomment >> GP.s_A        //sub_A         >> datacomment >> GP.ds         //Ds         >> datacomment >> GP.eta_n      //eta_net         >> datacomment >> GP.eta_s      //eta_sol         >> datacomment >> GP.rho_n      //rho_net         >> datacomment >> GP.rho_s;      //rho_sol  ifile.close();  //Nondimensionalize the global parameters  GP.To_Nondimension(CP);}//************************************************************************************************************************//function to display the dimensional  global physical parameters, such Gamma_1, Gamma_2, Kai, eta_n, eta_s, rho_n,// rho_s, i.e., the raw parameters read in ....void Global_Parameter::display(char* filename) const {  ofstream ofile(filename,ios::out);  if(!ofile)    {      cout << endl << " Can not open output file " << filename <<", ERROR in  Global_Parameter::display, "           << " Drive_ConstRho_2time.cpp !!!!!!!!!!!" << endl << endl;      exit(-1);    }  ofile << endl << endl << "***************************** The Raw Global Parameters ******************* " << endl << endl;  ofile   << endl << " KB = " << KB         //KB	  << endl << " T = " <<  T          //Temperature	  << endl << " gam_1 = " <<  gam_1      // Gamma_1	  << endl << " gam_2 = " << gam_2      //Gamma_2	  << endl << " kai_CH = " <<  kai_CH     //Kai_CH	  << endl << " np_inv = " <<  np_inv     //NP_in	  << endl << " phi_reg = " <<  phi_reg    //PHI_reg	  << endl << " lam = " <<  lam        //Lambda	  << endl << " s_eps = " <<  s_eps      //epsilon	  << endl << " s_mu = " <<  s_mu       //sub_mu	  << endl << " s_K_c = " <<  s_K_c      //sub_K_c	  << endl << " s_A = " <<  s_A        //sub_A	  << endl << " ds = " <<  ds         //Ds	  << endl << " eta_n = " << eta_n      //eta_net	  << endl << " eta_s = " <<  eta_s      //eta_sol	  << endl << " rho_n = " <<  rho_n      //rho_net	  << endl << " rho_s = " <<  rho_s;     //rho_sol  ofile.close();} //************************************************************************************************************************//function to read in the control parameters such as dx, dy , Nx, k (m = 2^(k+1), Ny = m )//total time T_final, CFL, tolerance of GMRES, ...void Read_Control_Parameters(char* filename, Control_Parameter& CP){  ifstream ifile(filename, ios::in);  if( !ifile)    {      cout << " \n\t Can not open the control parameters file " << filename << " !! " << endl;      exit(-1);    }  char datacomment[200];  ifile  >> datacomment >> CP.dx         >> datacomment >> CP.dy         >> datacomment >> CP.Nx         >> datacomment >> CP.k         >> datacomment >> CP.T_final         >> datacomment >> CP.CFL         >> datacomment >> CP.GMRES_tol         >> datacomment >> CP.GMRES_max_k         >> datacomment >> CP.Init_flag         >> datacomment >> CP.velo_flag         >> datacomment >> CP.Init_N         >> datacomment >> CP.Init_height_flag         >> datacomment >> CP.BC_flag         >> datacomment >> CP.Grid_flag         >> datacomment >> CP.rho_0         >> datacomment >> CP.c_0         >> datacomment >> CP.h         >> datacomment >> CP.t_0         >> datacomment >> CP.F_Stride         >> datacomment >> CP.tfac         >> datacomment >> CP.alph         >> datacomment >> CP.Ini_phi         >> datacomment >> CP.Ini_c         >> datacomment >> CP.Ini_ce         >> datacomment >> CP.Ini_c_omega         >> datacomment >> CP.t_cutoff_c                  >> datacomment >> CP.Shear_v         >> datacomment >> CP.Shear_ve         >> datacomment >> CP.Shear_omega         >> datacomment >> CP.t_cutoff_shear         >> datacomment >> CP.eps_dif         >> datacomment >> CP.N_dif_steps         >> datacomment >> CP.Difu_Init_flag;  ifile.close();}//************************************************************************************************************************//function to display the control parameters such as dx, dy , Nx, k (m = 2^(k+1), Ny = m )//total time T_final, CFL, tolerance of GMRES, ...void Control_Parameter::display(char* filename) const {  ofstream ofile(filename,ios::out);  if(!ofile)    {      cout << endl << " Can not open output file " << filename <<", ERROR in  Control_Parameter::display, "           << " Drive_ConstRho_2time.cpp !!!!!!!!!!!" << endl << endl;      exit(-1);    }  ofile << endl << endl << "********************* The Raw Control Parameters ***************************" << endl << endl;  ofile  << endl <<  " dx = " << dx         << endl <<  " dy = " << dy         << endl <<  " Nx = " << Nx         << endl <<  " k  = " << k         << endl <<  " Tfinal = " << T_final         << endl <<  " CFL = " << CFL         << endl <<  " GMRES_tol = " << GMRES_tol         << endl <<  " GMRES_max_k = " << GMRES_max_k         << endl <<  " Init_flag = " << Init_flag         << endl <<  " velo_flag = " << velo_flag         << endl <<  " Init_N = " << Init_N	 << endl <<  " Init_height_flag  = " << Init_height_flag         << endl <<  " BC_flag = " << BC_flag         << endl <<  " Grid_flag = " << Grid_flag         << endl <<  " rho_0 = " << rho_0         << endl <<  " c_0 = " << c_0         << endl <<  " h = " << h         << endl <<  " t_0 = " << t_0         << endl <<  " F_Stride = " << F_Stride         << endl <<  " Tfac = " << tfac         << endl <<  " alpha = " << alph         << endl <<  " Ini_phi = " << Ini_phi         << endl <<  " Ini_c = " << Ini_c          << endl <<  " Ini_ce = " << Ini_ce         << endl <<  " Ini_c_omega = " << Ini_c_omega            << endl <<  " t_cutoff_c = " << t_cutoff_c         << endl <<  " Shear_v = " << Shear_v         << endl <<  " Shear_ve = " << Shear_ve         << endl <<  " Shear_omega = " << Shear_omega         << endl <<  " t_cutoff_shear = " << t_cutoff_shear         << endl <<  " eps_dif = " << eps_dif         << endl <<  " N_dif_steps = " << N_dif_steps         << endl <<  " Diffusion const of Initial = " << Difu_Init_flag;  ofile.close();}//************************************************************************************************************************//function to save the  the final result void Save_Final_Data(char* filename, const Node_Data& un, const Node_Data& vn, const Node_Data& phi_n,                      const Node_Data& c_n){  ofstream ofile(filename, ios::out);  if(!ofile)    {      cout << endl << "Can not open output file " << filename << ", ERROR in Save_Final_Data() at Driver.cc" << endl;      exit(-1);    }  ofile << un.get_Nx() << endl << un.get_Ny() << endl;  ofile << un << endl;  ofile << vn << endl;  ofile << phi_n << endl;  ofile << c_n << endl;  ofile.close();}//************************************************************************************************************************//function to save the intermediate data for later restart, so save the result at time step n and n-1,//also need to save the time step size at n and n-1 for the use in extrapolation, and the current timevoid Save_Inter_Data(char* filename, const Node_Data& un, const Node_Data& vn, const Node_Data& un_1,                      const Node_Data& vn_1, const Node_Data& p, const Node_Data& s, double* s_stg, const Node_Data& phi_n,                      const Node_Data& phi_n_1, const Node_Data& c_n, const Node_Data& c_n_1,                     double dt_n, double dt_n_1, double T_current,  int Inter_file_NO, int n){  ofstream ofile(filename, ios::out);  if(!ofile)    {      cout << endl << "Can not open output file " << filename << ", ERROR in Save_Inter_Data() at Driver.cc" << endl;      exit(-1);    }  ofile << un.get_Nx() << endl << un.get_Ny() << endl << dt_n << endl << dt_n_1         << endl << T_current << endl <<  Inter_file_NO << endl << n << endl;  ofile << un << endl;  ofile << vn << endl;  ofile << un_1 << endl;  ofile << vn_1 << endl;  ofile << p << endl;  ofile << s << endl;  ofile << phi_n << endl;  ofile << phi_n_1 << endl;  ofile << c_n << endl;  ofile << c_n_1 << endl;  int i, j, Nx, Ny;  Nx = un.get_Nx();  Ny = un.get_Ny();  //output the pressure for half-staggered grid  ofile << endl;  for(j = 0; j <= Ny-1; j++)    {      for(i = 0; i <= Nx; i++)	ofile << s_stg[j*(Nx+1)+i] << "  ";      ofile << endl;    }   ofile.close();}//************************************************************************************************************************//function to read in the saved intermediate datavoid Read_Inter_Data(char* filename,  size_t Nx, size_t Ny, Node_Data& un,  Node_Data& vn,  Node_Data& un_1,                      Node_Data& vn_1, Node_Data& p, Node_Data& s, double* s_stg, Node_Data& phi_n,  Node_Data& phi_n_1,  Node_Data& c_n,		     Node_Data& c_n_1, double& dt_n, double& dt_n_1, double& T_current, int& Inter_file_NO, int& n){  ifstream ifile(filename, ios::in);  if(!ifile)    {      cout << endl << "Can not open input file " << filename << ", ERROR in Read_Inter_Data() at Driver.cc" << endl;      exit(-1);    }  size_t nx, ny;  ifile >> nx >> ny;  if(nx != Nx || ny != Ny)    {      cout << endl << "Read in dimension incompatible with the internal dimension. ERROR in Read_Inter_Data() in "            << " Driver.cc !! " << endl;      exit(-1);    }  ifile >> dt_n >> dt_n_1 >> T_current >> Inter_file_NO >> n;  ifile >> un >> vn >> un_1 >> vn_1 >> p >> s >> phi_n >> phi_n_1 >> c_n >> c_n_1;  //read  the pressure for half-staggered grid  for(int j = 0; j <= Ny-1; j++)      for(int i = 0; i <= Nx; i++)	ifile >> s_stg[j*(Nx+1)+i];   ifile.close();}//************************************************************************************************************************//function to setup the initial conditinos, use flag to indicate the method to set the initial condition//flag >= 0, different value corresponding to different initial datavoid Set_Initial_Condition(char* fname, int flag, Node_Data& phi, Node_Data& u, Node_Data& v, Node_Data& c,                           double dx, double dy, int N, const Control_Parameter& CP){  int i, j, Nx, Ny, seed, iN, Init_height_flag, velo_flag;  double x, y, d, a, tmp, dNx, Ini_phi, Ini_c, Shear_v, xL, hxL;  double ran_coe[N];  double ran_r[N];   //radius of random islands for initial phi_n  double ran_x[N];   //x-coordinate of the center of the random islands  double ran_y[N];   //y-coordinates ..................................  double ran_phi[N]; //height of the random islands  Nx = u.get_Nx();  Ny = u.get_Ny();  Ini_phi = CP.Ini_phi;  Ini_c = CP.Ini_c;  Shear_v = CP.Shear_v;  Init_height_flag = CP.Init_height_flag;  velo_flag = CP.velo_flag;  Node_Data phi_temp(Nx,Ny);  if(flag == 100) //read phi from a file, set other variables as usual    {      ifstream ifile(fname,ios::in);      if(!ifile)	{	  cout << endl << " Can not open input file " << fname << ", ERROR in Set_Initial_Condition() in Driver_2D_fish.cpp !! " << endl;          exit(-1);	}      ifile >> phi_temp;      ifile.close();    }        //get the random coefficient  seed = time(0);  srand(seed);  for(i = 0; i < N; i++)    {      ran_coe[i] = 2.0*rand()/double(RAND_MAX) - 1.0;       ran_r[i] = 0.04*rand()/double(RAND_MAX) + 0.01;      ran_x[i] = 0.8*rand()/double(RAND_MAX) + 0.1;       ran_y[i] = 0.45*rand()/double(RAND_MAX) + 0.05;      ran_phi[i] = 0.1*rand()/double(RAND_MAX) + 0.05;    }  xL = dx*(Nx+1);  //the x-length of domain  hxL = .5*xL;     //half size of x-length  dNx = xL/double(N); // 1.0/double(N);  for(j = 0; j <= Ny; j++)    for(i = 0; i <= Nx + 1; i++)      {	x = i*dx;	y = j*dy;      	if(velo_flag >= 1) //shear velocity	  {	    u[i][j] = Shear_v*(tanh(10*(y-1))+1) ;	    v[i][j] = 0.0;	  }	else if(velo_flag == 0) //zero-initial velocity	  {	    u[i][j] = 0.0;	    v[i][j] = 0.0;	  }	else	  {	    cout << endl << endl << "velo_flag in Set_Initial_Condition must be 0 or 5, ERROR in Driver_2D_new.cpp !!! " << endl;	    exit(-1);	  }	c[i][j] = Ini_c;	if(flag == 0)	    // one rectangle bump in the center (same for all mesh)	  {	    if(y <= 1.0/8 ||(x >= 3.0/8 && x <= 5.0/8 && y <= 1.0/4))	      phi[i][j] = Ini_phi;	    else	      phi[i][j] = 0.0;	  }	else if(flag == 1) // one bump in the center	  {	    // one bump in the center	    //            if(y <= .1 || (x >= .4 && x <= .6 && y <= (.1 + .1*sin((x- .4)*5*PI))))	    // a = 10;	    //            if(y <= .1 || (x > .4 && x < .6 && y <= (.1 - a*(x - .5)*(x - .5) + .01*a)))            if(y <= .1 || (x > .4*xL && x < .6*xL && y <= (exp(-.01*xL*xL/(.01*xL*xL  - (x - hxL)*(x - hxL)))/exp(-1.0)*.1 + .1)))	      phi[i][j] = Ini_phi;	    else              phi[i][j] = 0.0;	  }        else if (flag == 2) // A rectangle penisular on a flat base	  {            if(y <= dy*(Ny/8) )              phi[i][j] = Ini_phi;            else if( x >= dx*((Nx+1)/8) && x <= dx*((Nx+1)/8 + 8) && y <= dy*Ny/2)              phi[i][j] = Ini_phi;	    else              phi[i][j] = 0.0;	  }	else if(flag == 3) //periodic initial profile	  {	    if(y <= .1*sin(2*PI*(x - .25/N)*N) + .25)	      phi[i][j] = Ini_phi;	    else	      phi[i][j] = 0.0;	  }        else if(flag == 4) // a ball above flat base, try to catch rolling effect	  {	    double xb, y1, yb, rb, d;            y1 = 5.0/64;            rb = 6.0/64;            xb = 15.0/64;            yb = y1 + rb;            d = sqrt((x - xb)*(x - xb) + (y - yb)*(y - yb));	    if(y <= y1 + (1.0/64)*(2*rand()/double(RAND_MAX) - 1) )              phi[i][j] = Ini_phi;	    else if(d <= rb*(1 + .1*(2*rand()/double(RAND_MAX) - 1)))              phi[i][j] = Ini_phi*tanh(6.0*(1 - d/rb));	  }        else if(flag == 5) //flat interface, but perturbed magnitude of phi_n	  {            if(y <=.1)	      {              phi[i][j] = Ini_phi;	      }	    else if(y > .1 && y <= .15)	      {		if(x < xL)		  {                    iN = int(floor(x/dNx));		    phi[i][j] = Ini_phi + .7*Ini_phi*ran_coe[iN];		  }		else		  {		    phi[i][j] = phi[i-1][j];		  }	      }	    else	      {		phi[i][j] = 0.0;	      }	  }        else if(flag == 6) // grow-one bar, connected to the base	  {            double x1L, x1R, x2L, x2R, slop;            slop = 2.5;            x1L = 100.0/64;            x1R = 112.0/64;                        x2L = 54.0/64;            x2R = 74.0/64; 	    if(y <= 6.0/64)              phi[i][j] = Ini_phi;//             else if( y <= 18.0/64 && ( x >= (y - 6.0/64)/slop + x1L && x <= -(y - 6.0/64)/slop + x1R))//               phi[i][j] = Ini_phi*(1 - 2.4*(y - 6.0/64));            else if( y <= 25.0/64 && ( x >= (y - 6.0/64)/slop + x2L && x <= -(y - 6.0/64)/slop + x2R))              phi[i][j] = Ini_phi*(1 - 2.4*(y - 6.0/64));	  }        else if(flag == 7) // one bump with inhomogeneous, thin neck	  {            double xbL, xbR, xbC, rb, dxb, yb1, yb2, qua_a, qua_h, slope;            xbL = .2*xL;            xbR = .4*xL;            xbC = .5*(xbL + xbR);            rb  = .5*(xbR - xbL);            yb1 = 3.0/64;            yb2 = 23.0/64;            qua_h = .1;            qua_a = - qua_h/rb/rb;            slope = (.28*Ini_phi - Ini_phi)/(yb2 + qua_h - yb1);            int num_hole, i_hole;            num_hole = 5;            double yhole[num_hole];            dxb = (xbR - xbL)/num_hole;	    seed = time(0);	    srand(seed);	    for(i_hole= 0; i_hole < num_hole; i_hole++)	      {		yhole[i_hole] = (0.3*rand()/double(RAND_MAX) + .35)*(yb2 - yb1) + yb1; 	      }            if(y <= yb1)	      phi[i][j] = Ini_phi;	    else if(x >= xbL && x <= xbR && y <= yb2 + qua_a*((x - xbC)*(x - xbC) - rb*rb) ) // in the bump	      {                phi[i][j] = Ini_phi + slope*(y - yb1);		for(i_hole = 0; i_hole < num_hole; i_hole++)		  {		    if(x >= xbL + i_hole*dxb + 3*dx && x <= xbL + i_hole*dxb + 7*dx && y <= yhole[i_hole])		      {			phi[i][j] = 0.0;			break;		      }		  }	      } 	  }		else if(flag == 8)  //isolated islands, random positions, random heights	  {            phi[i][j] = 0.0;            for(int k = 0; k < N; k++)	      {	       if((x - ran_x[k])*(x - ran_x[k]) + (y - ran_y[k])*(y - ran_y[k]) <= ran_r[k]*ran_r[k] )		 {		   phi[i][j] = ran_phi[k];                   break;		 }	      }	  }	else if(flag == 9) //grow one, away from the base so the neck has low phi value	  {	    if( y <= 6.0/64)              phi[i][j] = Ini_phi;// 	       else if( fabs(x - (hxL - 3.0*xL/32)) <= dx && (y >= 4.0/32 && y <= 0.3) ) // 	         phi[i][j] = Ini_phi*(1 - 2.4*y);//             else if( fabs(x - (hxL + 3.0*xL/32)) <= dx && (y >= 4.0/32 && y <= 0.3) )//               phi[i][j] = Ini_phi*1.1*(1 - 2.4*y);            else if( fabs(x - 1.0) <= dx && (y >= 4.0/32 && y <= 25.0/64) )              phi[i][j] = Ini_phi*1.1*(1 - 2.4*y);	  }	else if(flag == 10) //grow two spots	  {	    double x1, y1, x2, y2, r1, r2;            x1 = 25.0/64;            y1 = 0.0;            r1 = 10.0/64;            x2 = 73.0/64;            y2 = 0.0;            r2 = 5.0/64;              if( (x - x1)*(x - x1) + (y - y1)*(y - y1) <= r1*r1 )              phi[i][j] = Ini_phi;	    else if( (x - x2)*(x - x2) + (y - y2)*(y - y2) <= r2*r2 )              phi[i][j] = 1.1*Ini_phi;	    else 	      phi[i][j] = 0.0;	  }	else if(flag == 11) //grow two spots with smaller spots randomly distributed on the surface	  {	    double x1, y1, x2, y2, r1, r2, xi, yi, ri;            double ran_angle[3];            x1 = 25.0/64;            y1 = 0.0;            r1 = 15.0/64;            x2 = 100.0/64;            y2 = 0.0;            r2 = 20.0/64;            ri = 2.0/64;              ran_angle[0] = .2*PI;            ran_angle[1] = .5*PI;            ran_angle[2] = .8*PI;            if( (x - x1)*(x - x1) + (y - y1)*(y - y1) <= r1*r1 )              phi[i][j] = Ini_phi;	    else if( (x - x2)*(x - x2) + (y - y2)*(y - y2) <= r2*r2 )              phi[i][j] = 1.1*Ini_phi;	    else 	      phi[i][j] = 0.0;            for(int ia = 0; ia < 3; ia++)	      {		xi = x1 + r1*cos(ran_angle[ia]);                yi = y1 + r1*sin(ran_angle[ia]);		if( (x - xi)*(x - xi) + (y - yi)*(y - yi) <= ri*ri )		  {		    phi[i][j] = Ini_phi;		    break;		  }		xi = x2 + r2*cos(ran_angle[ia]);                yi = y2 + r2*sin(ran_angle[ia]);		if( (x - xi)*(x - xi) + (y - yi)*(y - yi) <= ri*ri )		  {		    phi[i][j] = Ini_phi;		    break;		  }	      }	  }   	else if(flag == 100)	  {	    phi[i][j] = phi_temp[i][j];	  }        	else	  {	    cout << endl << "The initial flag is not in valid range, ERROR in Set_Initial_Condition() at Driver.cc !! "                  << endl;	    exit(-1);	  }      }}//************************************************************************************************************************void Diffuse_Initial_Condition(Node_Data& phi, int N_steps, double dx, double dy, double dt, double alpha, double eps_dif){  int i, Nx, Ny, GMRES_flag, GMRES_max_k, GMRES_num_restart, GMRES_num_k;  double GMRES_tol, GMRES_res;  GMRES_max_k = 30;  GMRES_tol = 1e-8;  Nx = phi.get_Nx();  Ny = phi.get_Ny();  c_NoFlux_x_NoFlux_y_mat A(Nx, Ny);  valarray<double> F(A.get_dim());  valarray<double> rhs(F.size());  for(i = 0; i < N_steps; i++)    {      Build_Diffusion(A, F, phi, dx, dy, dt, alpha, eps_dif);      //solve for new phi by GMRES      GMRES(A, F, rhs, GMRES_tol, GMRES_max_k, GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);           //update phi after one step of diffusion      Update_Node_Data_N_x_N_y(phi, rhs);    }}//************************************************************************************************************************//function to update a Node_Data variable with periodic BC in x-direction and, Dirichelet BC  in y-direction,//should be used for u, v and phi: the velocity and the network concentrationvoid Update_Node_Data_P_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+1)*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_P_x_D_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    {      for(i = 0; i <= Nx; i++)	u[i][j] = x[(j-1)*(Nx+1) + i];         //set value at i = Nx + 1 equal to those at i = 0      u[Nx+1][j] = u[0][j];    }}//************************************************************************************************************************void Update_Node_Data_D_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if(Nx*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_D_x_D_y(), "           << " ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    {     for(i = 1; i <= Nx; i++)       u[i][j] = x[(j-1)*Nx + i - 1];    }}//************************************************************************************************************************void Update_Node_Data_OutFlow_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if(Nx*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_OutFlow_x_D_y(), "           << " ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    {     for(i = 1; i <= Nx; i++)       u[i][j] = x[(j-1)*Nx + i - 1];     u[0][j] = u[1][j];     //2.0*u[1][j] - u[2][j];     u[Nx+1][j] = u[Nx][j]; //2.0*u[Nx][j] - u[Nx-1][j];    }}//************************************************************************************************************************void Update_Node_Data_P_x_N_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+1)*(Ny+1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_P_x_N_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 0; j <= Ny; j++)    {      for(i = 0; i <= Nx; i++)	u[i][j] = x[j*(Nx+1) + i];      //set value at i = Nx + 1 equal to those at i = 0      u[Nx+1][j] = u[0][j];    }}//************************************************************************************************************************void Update_Node_Data_N_x_N_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*(Ny+1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_N_x_N_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 0; j <= Ny; j++)    {      for(i = 0; i <= Nx + 1; i++)	u[i][j] = x[j*(Nx+2) + i];    }}//************************************************************************************************************************void Update_Node_Data_N_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_N_x_D_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 1; j <= Ny-1; j++)    {      for(i = 0; i <= Nx + 1; i++)	u[i][j] = x[(j-1)*(Nx+2) + i];    }}//************************************************************************************************************************void Update_Node_Data_N_x_D_N_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*Ny != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_N_x_D_N_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 0; j <= Ny-1; j++)    {      for(i = 0; i <= Nx + 1; i++)	u[i][j] = x[j*(Nx+2) + i];    }}//************************************************************************************************************************void Update_Node_Data_P_x_D_N_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+1)*Ny != x.size())    {      cout << endl << " Dimension Incompatible in Update_Node_Data_P_x_D_N_y(), ERROR in Driver.cc !!!!!!!!!!! " << endl;      exit(-1);    }  for(j = 0; j <= Ny-1; j++)    {      for(i = 0; i <= Nx; i++)	u[i][j] = x[j*(Nx+1) + i];      u[Nx+1][j] = u[0][j];    }}//************************************************************************************************************************void ADD_Update_Node_Data_P_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Add_Update_Node_Data_P_x_D_y(), ERROR in Driver.cc !!!!!!!!!!! "           << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    {      for(i = 0; i <= Nx; i++)	u[i][j] += x[(j-1)*(Nx+2) + i];        //set value at i = Nx + 1 equal to those at i = 0      u[Nx+1][j] = u[0][j];    }}//************************************************************************************************************************void ADD_Update_Node_Data_D_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Add_Update_Node_Data_D_x_D_y(), ERROR in Driver.cc !!!!!!!!!!! "           << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    for(i = 1; i <= Nx; i++)      u[i][j] += x[(j-1)*(Nx+2) + i];}//************************************************************************************************************************void ADD_Update_Node_Data_OutFlow_x_D_y(Node_Data& u, const valarray<double>& x){  int i, j, Nx, Ny;  Nx = u.get_Nx();  Ny = u.get_Ny();  if((Nx+2)*(Ny-1) != x.size())    {      cout << endl << " Dimension Incompatible in Add_Update_Node_Data_OutFlow_x_D_y(), ERROR in Driver.cc !!!!!!!!!!! "           << endl;      exit(-1);    }  for(j = 1; j <= Ny - 1; j++)    {     for(i = 1; i <= Nx; i++)       u[i][j] += x[(j-1)*(Nx+2) + i];     u[0][j] = u[1][j];     //2.0*u[1][j] - u[2][j];     u[Nx+1][j] = u[Nx][j]; //2.0*u[Nx][j] - u[Nx-1][j];    }}//************************************************************************************************************************void Update_Velo_By_Momentum(Node_Data& u, const valarray<double>& x, int bc_flag){  if(bc_flag == 0 || bc_flag == 3) //periodic BC    Update_Node_Data_P_x_D_y(u, x);  else if(bc_flag == 1)  //no-flux in x and y-direction (i.e. Dirichelete BC for u, v in x-directino)    Update_Node_Data_D_x_D_y(u, x);  else if(bc_flag == 2)  //out-flow BC in x-direction    Update_Node_Data_OutFlow_x_D_y(u, x);  else    {      cout << endl << " bc_flag must be 0, 1 , 2, 3, ERROR in Update_Velo_By_Momentum() at Driver.cc() !!! " << endl ;      exit(-1);    } }//************************************************************************************************************************void Update_Velo_By_Pressure(Node_Data& u, const valarray<double>& x, int bc_flag){  if(bc_flag == 0 || bc_flag == 3) //periodic BC    ADD_Update_Node_Data_P_x_D_y(u, x);  else if(bc_flag == 1)  //no-flux in x-direction (i.e. Dirichelete BC for u, v in x-directino)    ADD_Update_Node_Data_D_x_D_y(u, x);  else if(bc_flag == 2)  //out-flow BC in x-direction    ADD_Update_Node_Data_OutFlow_x_D_y(u, x);  else    {      cout << endl << " bc_flag must be 0, 1 , 2, 3, ERROR in Update_Velo_By_Pressure() at Driver.cc() !!! " << endl ;      exit(-1);    } }//************************************************************************************************************************void Update_c(Node_Data& c, const valarray<double>& x, int bc_flag, double t_current, const Control_Parameter& CP){  if(bc_flag == 0)        Update_Node_Data_P_x_D_N_y(c, x);  else if(bc_flag == 1)     Update_Node_Data_N_x_D_N_y(c, x);       //update c at y = 1, it may depend on time  int i, Nx, Ny;  Nx = c.get_Nx();  Ny = c.get_Ny();  for(i = 0; i <= Nx + 1; i++)    c[i][Ny] = CP.Ini_c + CP.Ini_ce*sin(CP.Ini_c_omega*t_current);}//************************************************************************************************************************//function to average two Node_Data, the result is put into the second argument, and the first argument//is constantvoid Average_Node_Data(const Node_Data& v, Node_Data& u){  int i, Nx;  if(v.get_Nx() != u.get_Nx() || v.get_Ny() != u.get_Ny())    {      cout << endl << "Dimension Incompatible in Average_Node_Data() in Driver.cc !!! " << endl;      exit(-1);    }  Nx = v.get_Nx();  for(i = 0; i <= Nx + 1; i++)    u[i] = .5*(u[i] + v[i]);}//************************************************************************************************************************//function to calculate the time step dt at a given node point//given velocity u, v, sound of speed a, CFL number, dx, dy double Explicit_dt(double u, double v, double a, double dx, double dy, double cfl){  double dt = fabs(u)/dx + fabs(v)/dy + a*sqrt(1.0/dx/dx + 1.0/dy/dy);  dt = cfl/dt;  return dt;}//************************************************************************************************************************//function to calculate the time step for the time integration, //which is the smallest dt from all the node points, note here we treat speed of sound as a constantdouble Calculate_dt(const Node_Data& u, const Node_Data& v, double a, double dx, double dy, double cfl){  double dt, dt_min;  int i, j, Nx, Ny;  dt_min = 100;  Nx = u.get_Nx();  Ny = u.get_Ny();  for(j = 0; j <= Ny; j++)    for(i = 0; i <= Nx + 1; i++)      {        dt = Explicit_dt(u[i][j], v[i][j], a, dx, dy, cfl);        if(dt_min > dt)	  dt_min = dt;      }  return dt_min;}//************************************************************************************************************************double Cal_Ave_Viscosity(const Node_Data& phi){  int i, j, Nx, Ny, count;  double result;  Nx = phi.get_Nx();  Ny = phi.get_Ny();  result = 0.0;  count  = 0;  //result is the biggest entry of phi  for(i = 0; i <= Nx + 1; i++)    {      if(phi[i].max() > result)	result = phi[i].max();    }  return (eta_net - eta_sol)*result + eta_sol;}  //************************************************************************************************************************//the main driver function, integrate over timevoid Time_Evolve(char* filename){  int  Init_flag, Init_N, Osmo_flag, BC_flag, Grid_flag, GMRES_flag, GMRES_max_k, GMRES_num_restart, GMRES_num_k, F_Stride;  size_t Nx, Ny, k;  double dx, dy, T_final, CFL, GMRES_tol, GMRES_res, GMRES_Scale, Tfac, alpha, Lam_Helm_Velo;  time_t start, end, lin_s, lin_e;  double tdiff;  char control_file[80];  char global_file[80];  char Inter_file[80];  char phi_Inter_file[80];  char Final_file[80];  char datacomment[250];  ifstream ifile(filename,ios::in);  if(!ifile)    {      cout << endl << "Can not open input file " << filename << ", ERROR in Time_Eolve() at Driver.cc " << endl;      exit(-1);    }   //Read in the name of files containing the data  ifile >> datacomment >> control_file	>> datacomment >> global_file	>> datacomment >> Inter_file  	>> datacomment >> phi_Inter_file;  ifile.close();  //read in the control parameters  Control_Parameter CP;  Global_Parameter  GP;  Read_Control_Parameters(control_file, CP);  dx = CP.dx;  dy = CP.dy;  T_final = CP.T_final;  CFL = CP.CFL;  GMRES_tol = CP.GMRES_tol;  GMRES_max_k = CP.GMRES_max_k;    Nx = CP.Nx;  k = CP.k;  Ny = (1 << (k+1));  //Ny = m = 2^(k+1)  Init_flag = CP.Init_flag;  Init_N = CP.Init_N;  BC_flag = CP.BC_flag;  Grid_flag = CP.Grid_flag;  F_Stride = CP.F_Stride; //number of files skipped between the saved ones  Tfac = CP.tfac;  alpha = CP.alph;  //read in the global parameters  Read_Global_Parameters(global_file, GP, CP);  //*************************DEBUG*****************************  CP.display("/var/tmp/2D/Con_para");  GP.display("/var/tmp/2D/Glo_para");  Show_NonDimension_Para();  //*************************DEBUG*****************************  //define the local  variables  int i, j, n, Inter_file_NO;    double dt_n, dt_n_1, T_current;  n = 0;  Inter_file_NO = 0;  T_current = 0.0;  Node_Data phi_np1(Nx, Ny);  Node_Data phi_n(Nx, Ny);  Node_Data phi_n_1(Nx, Ny);  Node_Data phis_np1(Nx, Ny);    Node_Data phis_n(Nx, Ny);  Node_Data phis_n_1(Nx, Ny);  Node_Data un(Nx, Ny);  Node_Data vn(Nx, Ny);  Node_Data un_1(Nx, Ny);  Node_Data vn_1(Nx, Ny);  Node_Data bar_u(Nx, Ny);  Node_Data bar_v(Nx, Ny);  Node_Data c_np1(Nx, Ny);  Node_Data c_n(Nx, Ny);  Node_Data c_n_1(Nx, Ny);  Node_Data s(Nx, Ny);  Node_Data p(Nx, Ny);  double s_stg[(Nx+1)*Ny];   //pressure for half-staggered grid, must initialize it as 0  for(i = 0; i < (Nx+1)*Ny; i++)    s_stg[i] = 0.0;  Node_Data mu(Nx, Ny);  //the average viscosity   Node_Data rho_np1(Nx, Ny);  Node_Data rho_n(Nx, Ny);  //variables for velocity update  double Fx[(Nx+2)*(Ny+1)];  double Fy[(Nx+2)*(Ny+1)];  //the following variables are same for all BCs  MultipleRHS d_press(Ny + 1, Nx + 2);  double d_press_stg[(Nx+1)*Ny];  valarray<double> p_x(0.0, (Nx+2)*(Ny-1));  valarray<double> p_y(0.0, (Nx+2)*(Ny-1));  Node_Data aux_s(Nx, Ny);   //variables for phi update  PhiMat_N_x_N_y A_phi_N(Nx, Ny); //for No-Flux BC in x and y-direction  valarray<double> F_phi_N(0.0, A_phi_N.get_dim());  valarray<double> d_phi_N(0.0, A_phi_N.get_dim());  //vector contain the new solution of phi  PhiMat_N_x_N_D_y A_phi_N_D(Nx, Ny); //for No-Flux BC in x and y-direction  valarray<double> F_phi_N_D(0.0, A_phi_N_D.get_dim());  valarray<double> d_phi_N_D(0.0, A_phi_N_D.get_dim());  //vector contain the new solution of phi  PhiMat_P_x_N_y A_phi_P(Nx, Ny); //for periodic BC in x-direction and no-flux in y   valarray<double> F_phi_P(0.0, A_phi_P.get_dim());  valarray<double> d_phi_P(0.0, A_phi_P.get_dim());  //vector contain the new solution of phi  PhiMat_P_x_N_D_y A_phi_P_D(Nx, Ny); //for periodic BC in x-direction and no-flux in y   valarray<double> F_phi_P_D(0.0, A_phi_P_D.get_dim());  valarray<double> d_phi_P_D(0.0, A_phi_P_D.get_dim());  //vector contain the new solution of phi  c_N_x_D_N_y_mat A_c_ND(Nx, Ny);  //for No-Flux BC in x-direction  valarray<double> F_c_ND(0.0, A_c_ND.get_dim());  valarray<double> d_c_ND(0.0, A_c_ND.get_dim());  c_P_x_D_N_y_mat A_c_P(Nx, Ny);  //for Periodic BC in x-direction  valarray<double> F_c_P(0.0, A_c_P.get_dim());  valarray<double> d_c_P(0.0, A_c_P.get_dim());  //auxiliary variables for solving the Helmholtz and Poisson equation  double bda[Ny+1], bdb[Ny+1], bdc[Nx+2], bdd[Nx+2], d_press_reg[(Nx+2)*(Ny+1)];  double v_bda, v_bdb, v_bdc, v_bdd;   int ierror;  double pertrb;  //**********************************DEBUG*********************************************************  ofstream debstat;  debstat.open("/var/tmp/2D/debstat.txt", ios::out);  char debfile[80];  //************************************************************************************************  //set the initial condition, set it by hand if Init_flag >= 0  if(Init_flag >= 0)    {      Set_Initial_Condition(phi_Inter_file, Init_flag, phi_n, un, vn, c_n, dx, dy, Init_N, CP);      if(CP.Difu_Init_flag == 1)	Diffuse_Initial_Condition(phi_n, CP.N_dif_steps, dx, dy, .1*dx, 1.0, CP.eps_dif); //here dt = dx      Confine_Node_Data(phi_n, 0, 1);      //******************************DEBUG*********************************************************      sprintf(debfile,"/var/tmp/2D/phi_%d",Inter_file_NO);      Write_Node_Data(debfile,phi_n);      sprintf(debfile,"/var/tmp/2D/u_%d",Inter_file_NO);      Write_Node_Data(debfile,un);      sprintf(debfile,"/var/tmp/2D/v_%d",Inter_file_NO);      Write_Node_Data(debfile,vn);      sprintf(debfile,"/var/tmp/2D/c_%d",Inter_file_NO);      Write_Node_Data(debfile,c_n);      Inter_file_NO++;      //******************************DEBUG*********************************************************      un_1 = un;      vn_1 = vn;      phi_n_1 = phi_n;      c_n_1 = c_n;      //also initialize phis       phis_n = 1.0 - phi_n;      phis_n_1 = phis_n;           rho_n = rho_net*phi_n + rho_sol*phis_n;      mu  = eta_net*phi_n + eta_sol*phis_n;//       //s = 0 for the first step//       Calculate_Osmotic(phi_n, osm, Osmo_flag);    }  else if(Init_flag == -1)    {      Read_Inter_Data(Inter_file, Nx, Ny, un, vn, un_1, vn_1, p, s, s_stg, phi_n, phi_n_1, c_n, c_n_1,                       dt_n, dt_n_1, T_current, Inter_file_NO, n);      //initialize other variables      phis_n = 1.0 - phi_n;      phis_n_1 = 1.0 - phi_n_1;      Inter_file_NO++;      rho_n = rho_net*phi_n + rho_sol*phis_n;      mu  = eta_net*phi_np1 + eta_sol*phis_np1;      cout << endl << endl << " Resume computation from previous saved data, Inter_file_NO = " << Inter_file_NO            << ", current time = " << T_current <<  endl << endl;    }  else    {      cout << endl << " Invalid value for Init_flag, it must be bigger than or equal to -1. ERROR in Time_Evolve() "           << " at Driver.cc!!!!!!!!!" << endl;      exit(-1);    }       //now do the time evolution  while(T_current < T_final)     {      dt_n = Tfac*dy;   //set dt = dx      dt_n_1 = dt_n;      time(&start);      //calculate the average viscosity      eta_ave = Cal_Ave_Viscosity(phi_n);      //update velocity      //buid the momentum equation according to BC_flag     if(Grid_flag == 0) //regular grid       Build_Moment_RHS_REG_GRID(Fx, Fy, rho_n, mu, un, vn, s, phi_n, T_current, dx, dy, dt_n, BC_flag, CP);       else if(Grid_flag == 1)  //half-staggered grid       Build_Moment_RHS_STG_GRID(Fx, Fy, rho_n, mu, un, vn, s_stg, phi_n, T_current, dx, dy, dt_n, BC_flag, CP);      //update previous data      un_1 = un;      vn_1 = vn;      //solve the momentum equation by the FISHPACK Helmholtz solver      Lam_Helm_Velo = -rho_n[0][0]/eta_ave/dt_n;            time(&lin_s);      if(BC_flag == 0)  //periodic in x and no-flux in y	{	  my_hwscrt(0, dx*(Nx+1), Nx+1, 0, &v_bda, &v_bdb, 0, dy*Ny, Ny, 1, &v_bdc, &v_bdd, Lam_Helm_Velo, Fx, Nx+2, pertrb, ierror);          if(ierror != 0)	    {              cout << endl << " Error in Helmholtz solver for x-velocity u at iteration n = " << n << ", ierror = " << ierror << endl;	      exit(-1);	    } 	  my_hwscrt(0, dx*(Nx+1), Nx+1, 0, &v_bda, &v_bdb, 0, dy*Ny, Ny, 1, &v_bdc, &v_bdd, Lam_Helm_Velo, Fy, Nx+2, pertrb, ierror);          if(ierror != 0)	    {              cout << endl << " Error in Helmholtz solver for y-velocity v at iteration n = " << n << ", ierror = " << ierror << endl;	      exit(-1);	    }	}      else if(BC_flag == 1) //No-flux in both x and y direction	{	  my_hwscrt(0, dx*(Nx+1), Nx+1, 1, &v_bda, &v_bdb, 0, dy*Ny, Ny, 1, &v_bdc, &v_bdd, Lam_Helm_Velo, Fx, Nx+2, pertrb, ierror);          if(ierror != 0)	    {              cout << endl << " Error in Helmholtz solver for x-velocity u at iteration n = " << n << ", ierror = " << ierror << endl;	      exit(-1);	    } 	  my_hwscrt(0, dx*(Nx+1), Nx+1, 1, &v_bda, &v_bdb, 0, dy*Ny, Ny, 1, &v_bdc, &v_bdd, Lam_Helm_Velo, Fy, Nx+2, pertrb, ierror);          if(ierror != 0)	    {              cout << endl << " Error in Helmholtz solver for y-velocity v at iteration n = " << n << ", ierror = " << ierror << ", pertrb = " << pertrb << endl;	      exit(-1);	    }	}       time(&lin_e);      //update u and v      Node_Data_Array_Conversion(un, Fx, 2);           Node_Data_Array_Conversion(vn, Fy, 2);           //********************DEBUG PURPOSE*****************************************************      if((n-1)%F_Stride == 0 || n ==0) //out result every F_Stride steps	{	  tdiff = difftime(lin_e, lin_s);          debstat << endl << "time used = " << tdiff << " seconds, "	          << " max(du) =  " << un.max() << ", min(du) = " << un.min()                   << " max(dv) =  " << vn.max() << ", min(dv) = " << vn.min()                  << endl;	}      //****************************DEBUG********************************************************       //pressure update, Note here we assume density rho is a constant and use the fast Poisson solver      //it may need modification for variable density!!!!!!!!!!  here d_press = pressure_phi/rho      if(Grid_flag == 0)  //regular grid	Build_Poisson_RHS_REG_GRID((-1.0)*un, (-1.0)*vn, dx, dy, d_press, BC_flag);  //d_press = -div(U)      else if(Grid_flag == 1) //half-staggered grid	Build_Poisson_RHS_STG_GRID((-1.0)*un, (-1.0)*vn, dx, dy, d_press_stg, BC_flag); //d_press_stg = -div(U)//       //*************************************DEBUG*********************************************//       if((n-1)%F_Stride == 0 || n ==0) //out result every F_Stride steps// 	{// 	  sprintf(debfile,"/var/tmp/2D/divU_%d",Inter_file_NO);// 	  Write_MultipleRHS(debfile,d_press);// 	}//       //*************************************DEBUG*********************************************      //update s       if(Grid_flag == 0)	s = s + d_press;      else if(Grid_flag == 1)	Add_Array(s_stg, d_press_stg, (Nx+1)*Ny);            //call the fishpack subroutine to solve the poisson equation, put it in a block to avoid name confliction      {         //set the homogeneous Neumann BC        for(int i = 0; i <= Nx+1; i++)	  {	    bdc[i] = 0.0;            bdd[i] = 0.0;	  }        for(int j = 0; j <= Ny; j++)	  {            bda[j] = 0.0;            bdb[j] = 0.0;	  }        //convert the RHS to an array        if(Grid_flag == 0)   //regular grid	  {	    MultipleRHS_Array_Conversion(d_press_reg, d_press, 1);	    if(BC_flag == 0)       //periodic BC in x-direction	      my_hwscrt(0.0, dx*(Nx+1), Nx+1, 0, bda, bdb, 0.0, dy*Ny, Ny, 3, bdc, bdd, 0.0, d_press_reg, Nx+2, pertrb, ierror);	    else if(BC_flag == 1) //no-flux BC in x-direction	      my_hwscrt(0.0, dx*(Nx+1), Nx+1, 3, bda, bdb, 0.0, dy*Ny, Ny, 3, bdc, bdd, 0.0, d_press_reg, Nx+2, pertrb, ierror);	    // convert the RHS to MultipleRHS	    MultipleRHS_Array_Conversion(d_press_reg, d_press, 2);	  }	else if(Grid_flag == 1) //half-staggered grid	  {	    if(BC_flag == 0)       //periodic BC in x-direction	      my_hstcrt(0.0, dx*(Nx+1), Nx+1, 0, bda, bdb, 0.0, dy*Ny, Ny, 3, bdc, bdd, 0.0, d_press_stg, Nx+1, pertrb, ierror);	    else if(BC_flag == 1) //no-flux BC in x-direction	      my_hstcrt(0.0, dx*(Nx+1), Nx+1, 3, bda, bdb, 0.0, dy*Ny, Ny, 3, bdc, bdd, 0.0, d_press_stg, Nx+1, pertrb, ierror);	  }        if(ierror != 0) 	  {	    cout << endl << "Error in the poisson solver from fishpack for pressure at iteration n = " << n <<", ierror = " << ierror << ", pertrb = " << pertrb << endl;	  }      }      if(Grid_flag == 0)	d_press.To_Gradient(dx, dy, p_x, p_y, BC_flag);      else if(Grid_flag == 1)	STG_pressure_gradient(Nx, Ny, dx, dy, d_press_stg, p_x, p_y, BC_flag);      Update_Velo_By_Pressure(un, p_x, BC_flag);      Update_Velo_By_Pressure(vn, p_y, BC_flag);      //*************************************DEBUG*********************************************      if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	{	  debstat<< endl << "Pressure update: max(p_x) = " << p_x.max() << ", min(p_x) = " << p_x.min() 		 << ", max(p_y) = " << p_y.max() << ", min(p_y) = " << p_y.min() 		 << ", time used = " << tdiff << " seconds " << endl;    	}      //*****************************************************************************************      //update phi, the volume fraction of network      //Note here all the data are at the previous time step       if(BC_flag == 0) //periodic in x-direction	{	  if(CP.velo_flag == 1) //shear velocity	    Build_Phi_P_x_N_D_y_MCH(A_phi_P_D, F_phi_P_D, un_1, vn_1, phi_n, c_n, dx, dy, dt_n, alpha);	  else	    Build_Phi_P_x_N_y_MCH(A_phi_P, F_phi_P, un_1, vn_1, phi_n, c_n, dx, dy, dt_n, alpha);	}      else if(BC_flag == 1) //no-flux BC in x and y-direction	{	  if(CP.velo_flag == 1) //shear velocity	    Build_Phi_N_x_N_D_y_MCH(A_phi_N_D, F_phi_N_D, un_1, vn_1, phi_n, c_n, dx, dy, dt_n, alpha);	  else	    Build_Phi_N_x_N_y_MCH(A_phi_N, F_phi_N, un_1, vn_1, phi_n, c_n, dx, dy, dt_n, alpha);	}      //update previous data      phi_n_1 = phi_n;      phis_n = 1.0 - phi_n;      //get the max-element of A_phi to scale A and F_phi      if(BC_flag == 0) 	if(CP.velo_flag == 1)	  GMRES_Scale = A_phi_P_D.get_max_element();	else	  GMRES_Scale = A_phi_P.get_max_element();      else if(BC_flag == 1)	if(CP.velo_flag == 1)	  GMRES_Scale = A_phi_N_D.get_max_element();	else	  GMRES_Scale = A_phi_N.get_max_element();      //********************DEBUG PURPOSE*****************************************************      if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	{	  if(BC_flag == 0) 	    if(CP.velo_flag == 1)	      debstat << endl << "GMRES solver for phi at n =  " << n << ", t = " << T_current 		      <<", max(A_phi) = " << GMRES_Scale  << ", max(F_phi) = " << F_phi_P_D.max() << ", min(F_phi) = " << F_phi_P_D.min()  << endl;	    else	      debstat << endl << "GMRES solver for phi at n =  " << n << ", t = " << T_current 		      <<", max(A_phi) = " << GMRES_Scale  << ", max(F_phi) = " << F_phi_P.max() << ", min(F_phi) = " << F_phi_P.min()  << endl;	  else if(BC_flag == 1)	    if(CP.velo_flag == 1)	      debstat << endl << "GMRES solver for phi at n =  " << n << ",  t = " << T_current 		      <<", max(A_phi) = " << GMRES_Scale  << ", max(F_phi) = " << F_phi_N_D.max() << ", min(F_phi) = " << F_phi_N_D.min()  << endl;	    else	      debstat << endl << "GMRES solver for phi at n =  " << n << ",  t = " << T_current 		      <<", max(A_phi) = " << GMRES_Scale  << ", max(F_phi) = " << F_phi_N.max() << ", min(F_phi) = " << F_phi_N.min()  << endl;	}      //**************************************************************************************      //scale A and Fx, Fy      if(BC_flag == 0 ) 	{	  if(CP.velo_flag == 1)	    {	      A_phi_P_D.Scale();	      F_phi_P_D /= GMRES_Scale;	    }	  else	    {	      A_phi_P.Scale();	      F_phi_P /= GMRES_Scale;	    }	}      else if(BC_flag == 1)	{	  if(CP.velo_flag == 1)	    {	      A_phi_N_D.Scale();	      F_phi_N_D /= GMRES_Scale;	    }	  else	    {	      A_phi_N.Scale();	      F_phi_N /= GMRES_Scale;	    }	}      time(&lin_s);      if(BC_flag == 0) 	if(CP.velo_flag == 1)	  GMRES(A_phi_P_D, F_phi_P_D, d_phi_P_D, GMRES_tol, GMRES_max_k,  GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);	else	  GMRES(A_phi_P, F_phi_P, d_phi_P, GMRES_tol, GMRES_max_k,  GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);      else if(BC_flag == 1)	if(CP.velo_flag == 1)	  GMRES(A_phi_N_D, F_phi_N_D, d_phi_N_D, GMRES_tol, GMRES_max_k,  GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);	else	  GMRES(A_phi_N, F_phi_N, d_phi_N, GMRES_tol, GMRES_max_k,  GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);      time(&lin_e);      //********************DEBUG PURPOSE*****************************************************      if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	{	  tdiff = difftime(lin_e, lin_s);	  debstat<< endl << " Got out of  GMRES solver for phi, GMRES_res = " << GMRES_res << ", GMRES_num_restart = " << GMRES_num_restart  		 << " GMRES_num_k = " << GMRES_num_k << ", time used = " << tdiff << " seconds " << endl; 	  if(BC_flag == 0) 	    if(CP.velo_flag == 1)	      debstat<< endl << " max(d_phi) =  " << d_phi_P_D.max() 		     << ", min(d_phi) = " << d_phi_P_D.min() <<  endl;	    else	      debstat<< endl << " max(d_phi) =  " << d_phi_P.max() 		     << ", min(d_phi) = " << d_phi_P.min() <<  endl;	  else if(BC_flag == 1)	    if(CP.velo_flag == 1)	      debstat<< endl << " max(d_phi) =  " << d_phi_N_D.max() 		     << ", min(d_phi) = " << d_phi_N_D.min() <<  endl;	    else	      debstat<< endl << " max(d_phi) =  " << d_phi_N.max() 		     << ", min(d_phi) = " << d_phi_N.min() <<  endl;	}      //**************************************************************************************       if(BC_flag == 0) 	if(CP.velo_flag == 1)	  Update_Node_Data_P_x_D_N_y(phi_n, d_phi_P_D);	else	  Update_Node_Data_P_x_N_y(phi_n, d_phi_P);      else if(BC_flag == 1)	if(CP.velo_flag == 1)	  Update_Node_Data_N_x_D_N_y(phi_n, d_phi_N_D);	else	  Update_Node_Data_N_x_N_y(phi_n, d_phi_N);      //make sure phi is in [0,1]      Confine_Node_Data(phi_n, 0, 1);      //Do we still need this ????????????????????????????      //replace phi_n by its average with phi_n_1, reduce the oscillation by Crank-Nicolson scheme      //Average_Node_Data(phi_n_1,phi_n);        phis_np1 = 1.0 - phi_n;  //Here need special care, update phis later!!!!!!!!!!!         if(T_current < CP.t_cutoff_c)  // only calculate c before we cut the nutrient supply	{ 	  //update c, the concentration of the solvent	  if(BC_flag == 0) //periodic BC in x-direction	    Build_c_P_x_D_N_y_Order1(A_c_P, F_c_P, phi_n_1, phis_np1, phis_n, c_n, un_1, vn_1, T_current, dx, dy, dt_n, alpha, CP);	  if(BC_flag == 1) //no-flux BC in x-direction	    Build_c_N_x_D_N_y(A_c_ND, F_c_ND, phi_n_1, phis_np1, phis_n, c_n, un_1, vn_1, T_current, dx, dy, dt_n, CP);	  //update previous data	  c_n_1 = c_n;	  //get the max-element of A_c to scale A and F_c	  if(BC_flag == 0) 	    GMRES_Scale = A_c_P.get_max_element();	  else if(BC_flag == 1) 	    GMRES_Scale = A_c_ND.get_max_element();	  //********************DEBUG PURPOSE*****************************************************	  if((n-1)%F_Stride == 0) //out result every F_Stride steps	    {	      if(BC_flag == 0 ) 		debstat<< endl << "GMRES solver for c at n =  " << n << ", t = " << T_current 		       <<", max(A_c) = " << GMRES_Scale << ", max(F_c) = " << F_c_P.max() << ", min(F_c) = " << F_c_P.min()  << endl;	      else if(BC_flag == 1) 		debstat<< endl << "GMRES solver for c at n =  " << n << ", t = " << T_current 		       <<", max(A_c) = " << GMRES_Scale << ", max(F_c) = " << F_c_ND.max() << ", min(F_c) = " << F_c_ND.min() << endl;	      // 	    sprintf(debfile,"/var/tmp/2D/Ac_%d",Inter_file_NO);	      // 	    A_c_ND.Write_to_file(debfile);	      // 	    sprintf(debfile,"/var/tmp/2D/Fc_%d",Inter_file_NO);	      // 	    Write_Vector(debfile,F_c_ND,Nx+2);	    }	  //**************************************************************************************	  //scale A and Fx, Fy	  if(BC_flag == 0) 	    {	      A_c_P.Scale();	      F_c_P /= GMRES_Scale;	    }	  else if(BC_flag == 1) 	    {	      A_c_ND.Scale();	      F_c_ND /= GMRES_Scale;	    }	  time(&lin_s);	  if(BC_flag == 0) 	    GMRES(A_c_P, F_c_P, d_c_P, GMRES_tol, GMRES_max_k,  GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);	  else if(BC_flag == 1) 	    GMRES(A_c_ND, F_c_ND, d_c_ND, GMRES_tol, GMRES_max_k, GMRES_flag, GMRES_res, GMRES_num_restart, GMRES_num_k);	  time(&lin_e);	  //********************DEBUG PURPOSE*****************************************************	  if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	    {	      tdiff = difftime(lin_e, lin_s);	      debstat<< endl << " Got out of  GMRES solver for c,"		     << " GMRES_res = " << GMRES_res << ", GMRES_num_restart = " << GMRES_num_restart  		     << " GMRES_num_k = " << GMRES_num_k  << ", time used = " << tdiff << " seconds " << endl; 	      if(BC_flag == 0) 		debstat<< endl << "  max(d_c) =  " << d_c_P.max() 		       << ", min(d_c) = " << d_c_P.min() << endl;	      else if(BC_flag == 1) 		debstat<< endl << "Got out of  GMRES solver for c, max(d_c) =  " << d_c_ND.max() 		       << ", min(d_c) = " << d_c_ND.min() << endl;	      debstat<< endl << endl << "_________________________________________________________________________________"		     << endl << endl;	    }	  //**************************************************************************************  	  if(BC_flag == 0)    	    Update_c(c_n, d_c_P, BC_flag, T_current, CP);	  else if(BC_flag == 1) 	    Update_c(c_n, d_c_ND, BC_flag, T_current, CP);	  //make sure c is in [0,1]	  Confine_Node_Data(c_n, 0, 1);	}      else  //turn off the growth, don't calculate c	{	  sub_epsilon = 0.0;	}      //update phis for next timestep      phis_n = phis_np1;      //update the time information      n++;      T_current += dt_n;      //******************************DEBUG*********************************************************      if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	{	  sprintf(debfile,"/var/tmp/2D/phi_%d",Inter_file_NO);	  Write_Node_Data(debfile,phi_n);	  sprintf(debfile,"/var/tmp/2D/u_%d",Inter_file_NO);	  Write_Node_Data(debfile,un);	  sprintf(debfile,"/var/tmp/2D/v_%d",Inter_file_NO);	  Write_Node_Data(debfile,vn);	  sprintf(debfile,"/var/tmp/2D/P_%d",Inter_file_NO);          	  if(Grid_flag == 0)            Write_Node_Data(debfile,s);	  else if(Grid_flag == 1)            Write_Array(debfile, s_stg, (Nx+1)*Ny, Nx+1);	  if(T_current < CP.t_cutoff_c)	    {	      sprintf(debfile,"/var/tmp/2D/c_%d",Inter_file_NO);	      Write_Node_Data(debfile,c_n);	    } 	}      //******************************DEBUG*********************************************************      rho_n = rho_net*phi_n + rho_sol*phis_n;      mu  = eta_net*phi_n + eta_sol*phis_n;      //write the save intermediate data code here      if((n-1)%(20*F_Stride) == 0 || n == 0) //out result every F_Stride steps	{	  sprintf(Inter_file, "/var/tmp/2D/Inter_%d.data",Inter_file_NO);          Save_Inter_Data(Inter_file, un, vn, un_1, vn_1, p, s, s_stg, phi_n, phi_n_1, c_n, c_n_1,                           dt_n, dt_n_1, T_current, Inter_file_NO, n);       	}      time(&end);      tdiff = difftime(end, start);      //output current time and number of time steps      if((n-1)%F_Stride == 0 || n == 0) //out result every F_Stride steps	{	  cout << endl  << "_______________________________________________________________________________________" 	       << endl  <<  endl << " At time t = " << T_current << " after " << n << " time steps "	       << endl  << " The clock time is " << endl;           system("date");	  cout << endl << endl << " Time step " << n << " took " << tdiff << " seconds, dt_n = " << dt_n                << ", eta_ave = " << eta_ave << endl 	       << " L_infty norm of u is " << un.L_inf_norm() << ", L_infty norm of v is "  << vn.L_inf_norm()	       << endl << " max(phi) = " << phi_n.L_inf_norm() << ", total(phi) = " << phi_n.sum()*dx*dy	       << endl << " max(c) = " << c_n.L_inf_norm() << ", total(c) = " << c_n.sum()*dx*dy << endl;          Inter_file_NO++;	}    }       //save the final data here  sprintf(Final_file,"Final.data");  Save_Final_Data(Final_file, un, vn, phi_n, c_n);  //**********************************DEBUG*********************************************************  debstat.close();  Show_NonDimension_Para();  //************************************************************************************************      }    